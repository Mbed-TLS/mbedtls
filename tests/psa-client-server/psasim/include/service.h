/*
 *  Copyright The Mbed TLS Contributors
 *  SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later
 */

#ifndef __PSA_SERVICE_H__
#define __PSA_SERVICE_H__

#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>

#include "common.h"

#include "psa/crypto.h"


typedef uint32_t psa_signal_t;
typedef int32_t psa_handle_t;
#define PSA_NULL_HANDLE ((psa_handle_t) 0)

/**
 * Describe a message received by an RoT Service after calling \ref psa_get().
 */
typedef struct psa_msg_t {
    uint32_t type;              /* One of the following values:
                                 * \ref PSA_IPC_CONNECT
                                 * \ref PSA_IPC_CALL
                                 * \ref PSA_IPC_DISCONNECT
                                 */
    psa_handle_t handle;        /* A reference generated by the SPM to the
                                 * message returned by psa_get().
                                 */
    int32_t client_id;          /* Partition ID of the sender of the message */
    void *rhandle;              /* Be useful for binding a connection to some
                                 * application-specific data or function
                                 * pointer within the RoT Service
                                 * implementation.
                                 */
    size_t in_size[PSA_MAX_IOVEC]; /* Provide the size of each client input
                                    * vector in bytes.
                                    */
    size_t out_size[PSA_MAX_IOVEC];/* Provide the size of each client output
                                    * vector in bytes.
                                    */
} psa_msg_t;

/* Functions from the PSA Firmware Framework which are implemented. */

/**
 * \brief Wait for a message from the client to arrive. Fail if timeout expires.
 *
 * \param[in] signal_mask       Ignored parameter.
 * \param[in] timeout           Amount of seconds to wait for the client message
 *                              to arrive before returning a failure.
 *
 * \retval PSA_SUCCESS                          If a message is received from
 *                                              the client before timeout expires.
 * \retval PSA_ERROR_COMMUNICATION_FAILURE      If the timeout expires before any
 *                                              message is received.
 */
psa_status_t psa_wait(psa_signal_t signal_mask, uint32_t timeout);

/**
 * \brief Copy message's invec to the specified output buffer.
 *
 * \param[in] msg_handle        Ignored parameter.
 * \param[in] invec_idx         Index of the input vector to read from. Must be
 *                              less than \ref PSA_MAX_IOVEC.
 * \param[out] buffer           Buffer to copy the requested data to.
 * \param[in] num_bytes         Sizeo (in bytes) of the output buffer.
 *
 * \retval >0                   On success the number of bytes read to the buffer
 *                              is returned.
 * \retval 0                    On failure. This can either be due to:
 *                              - output buffer too small,
 *                              - invalid invec_idx, i.e. > PSA_MAX_IOVEC.
 */
size_t psa_read(psa_handle_t msg_handle, uint32_t invec_idx, void *buffer, size_t num_bytes);

/**
 * \brief Copy the content of the provided buffer into the specified outvec.
 *
 * \param[in] msg_handle        Ignored parameter.
 * \param[out] outvec_idx       Index of output vector in message to write to.
 *                              Must be less than \ref PSA_MAX_IOVEC.
 * \param[in] buffer            Buffer with the data to write.
 * \param[in] num_bytes         Number of bytes to write from the input buffer.
 *
 * \retval >0                   On success the number of written bytes is returned.
 * \retval 0                    On failure, which can happen if:
 *                              - outvec_idx is invalid, i.e. outvec_idx > PSA_MAX_IOVEC,
 *                              - the server tries to write a message when it's not
 *                                owning the shared memory.
 */
size_t psa_write(psa_handle_t msg_handle, uint32_t outvec_idx, const void *buffer,
                 size_t num_bytes);
/**
 * \brief Notify the client that a message is ready.
 *
 * \param[in] msg_handle        Ignored parameter.
 * \param[in] status            Ignored parameter.
 *
 * \retval PSA_SUCCESS          On success.
 * \retval PSA_ERROR_BAD_STATE  On failure. This happens when the server does not
 *                              own the shared memeory so it is not allowed to
 *                              modify its ownership.
 */
psa_status_t psa_reply(psa_handle_t msg_handle, psa_status_t status);

/* Functions from the PSA Firmware Framework which are not implemented. */

/**
 * \brief Retrieve the message which corresponds to a given RoT Service signal
 *        and remove the message from the RoT Service queue.
 *
 * \param[in] signal            The signal value for an asserted RoT Service.
 * \param[out] msg              Pointer to \ref psa_msg_t object for receiving
 *                              the message.
 *
 * \retval PSA_SUCCESS          Success, *msg will contain the delivered
 *                              message.
 * \retval PSA_ERR_NOMSG        Message could not be delivered.
 * \retval "Does not return"    The call is invalid because one or more of the
 *                              following are true:
 * \arg                           signal has more than a single bit set.
 * \arg                           signal does not correspond to an RoT Service.
 * \arg                           The RoT Service signal is not currently
 *                                asserted.
 * \arg                           The msg pointer provided is not a valid memory
 *                                reference.
 */
psa_status_t psa_get(psa_signal_t signal, psa_msg_t *msg);

/**
 * \brief Associate some RoT Service private data with a client connection.
 *
 * \param[in] msg_handle        Handle for the client's message.
 * \param[in] rhandle           Reverse handle allocated by the RoT Service.
 *
 * \retval void                 Success, rhandle will be provided with all
 *                              subsequent messages delivered on this
 *                              connection.
 * \retval "Does not return"    msg_handle is invalid.
 */
void psa_set_rhandle(psa_handle_t msg_handle, void *rhandle);

/**
 * \brief Clear the PSA_DOORBELL signal.
 *
 * \retval void                 Success.
 * \retval "Does not return"    The Secure Partition's doorbell signal is not
 *                              currently asserted.
 */
void psa_clear(void);

/**
 * \brief Send a PSA_DOORBELL signal to a specific Secure Partition.
 *
 * \param[in] partition_id      Secure Partition ID of the target partition.
 *
 * \retval void                 Success.
 * \retval "Does not return"    partition_id does not correspond to a Secure
 *                              Partition.
 */
void psa_notify(int32_t partition_id);

/**
 * \brief Skip over part of a client input vector.
 *
 * \param[in] msg_handle        Handle for the client's message.
 * \param[in] invec_idx         Index of input vector to skip from. Must be
 *                              less than \ref PSA_MAX_IOVEC.
 * \param[in] num_bytes         Maximum number of bytes to skip in the client
 *                              input vector.
 *
 * \retval >0                   Number of bytes skipped.
 * \retval 0                    There was no remaining data in this input
 *                              vector.
 * \retval "Does not return"    The call is invalid, one or more of the
 *                              following are true:
 * \arg                           msg_handle is invalid.
 * \arg                           msg_handle does not refer to a
 *                                \ref PSA_IPC_CALL message.
 * \arg                           invec_idx is equal to or greater than
 *                                \ref PSA_MAX_IOVEC.
 */
size_t psa_skip(psa_handle_t msg_handle, uint32_t invec_idx, size_t num_bytes);

/**
 * \brief Inform the SPM that an interrupt has been handled (end of interrupt).
 *
 * \param[in] irq_signal        The interrupt signal that has been processed.
 *
 * \retval void                 Success.
 * \retval "Does not return"    The call is invalid, one or more of the
 *                              following are true:
 * \arg                           irq_signal is not an interrupt signal.
 * \arg                           irq_signal indicates more than one signal.
 * \arg                           irq_signal is not currently asserted.
 */
void psa_eoi(psa_signal_t irq_signal);

void psa_panic(void);

/* Extra functions which are not part of the PSA Firmware Framework*/

/**
 * \brief Setup the shared memory that is used to perform the communication
 *        with the client.
 *
 * \retval PSA_SUCCESS                  On success.
 * \retval PSA_ERROR_GENERIC_ERROR      On failure if the shared memory cannot
 *                                      be initialized.
 */
psa_status_t psa_setup(void);

/**
 * \brief Close the shared memory.
 *
 * \retval  None
 */
void psa_close(void);

/**
 * \brief Return a unique identified for the PSA crypto API function that was
 *        called by the client.
 *
 * \retval int32_t              The unique code for the PSA crypto API function
 *                              called by the client. See "psa_functions_code.h"
 *                              for the list of IDs.
 */
int32_t psa_get_psa_function(void);

/**
 * \brief Return invec and outvec sizes from the client's message.
 *
 * \param invec_sizes[in/out]   Array of PSA_MAX_IOVEC elements representing the
 *                              sizes of the invecs.
 * \param outvec_sizes[in/out]  Array of PSA_MAX_IOVEC elements representing the
 *                              sizes of the outvecs.
 *
 * \retval  None
 */
void psa_get_vectors_sizes(size_t *invec_sizes, size_t *outvec_sizes);

#endif /* __PSA_SERVICE_H__ */
