/* THIS FILE WAS AUTO-GENERATED BY psa_sim_generate.pl. DO NOT EDIT!! */

/* client calls */

/*
 *  Copyright The Mbed TLS Contributors
 *  SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later
 */

#include <stdio.h>
#include <unistd.h>

/* Includes from psasim */
#include <client.h>
#include <util.h>
#include "psa_manifest/sid.h"
#include "psa_functions_codes.h"
#include "psa_sim_serialise.h"

/* Includes from mbedtls */
#include "mbedtls/version.h"
#include "psa/crypto.h"

#define CLIENT_PRINT(fmt, ...) \
    PRINT("Client: " fmt, ##__VA_ARGS__)

static psa_handle_t handle = -1;

#if defined(MBEDTLS_PSA_CRYPTO_C)
#error "Error: MBEDTLS_PSA_CRYPTO_C must be disabled on client build"
#endif

int psa_crypto_call(int function,
                    uint8_t *in_params, size_t in_params_len,
                    uint8_t **out_params, size_t *out_params_len)
{
    // psa_outvec outvecs[1];
    if (handle < 0) {
        fprintf(stderr, "NOT CONNECTED\n");
        exit(1);
    }

    psa_invec invec;
    invec.base = in_params;
    invec.len = in_params_len;

    size_t max_receive = 8192;
    uint8_t *receive = malloc(max_receive);
    if (receive == NULL) {
        fprintf(stderr, "FAILED to allocate %u bytes\n", (unsigned) max_receive);
        exit(1);
    }

    size_t actual_received = 0;

    psa_outvec outvecs[2];
    outvecs[0].base = &actual_received;
    outvecs[0].len = sizeof(actual_received);
    outvecs[1].base = receive;
    outvecs[1].len = max_receive;

    psa_status_t status = psa_call(handle, function, &invec, 1, outvecs, 2);
    if (status != PSA_SUCCESS) {
        free(receive);
        return 0;
    }

    *out_params = receive;
    *out_params_len = actual_received;

    return 1;   // success
}

psa_status_t psa_crypto_init(void)
{
    char mbedtls_version[18];
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    mbedtls_version_get_string_full(mbedtls_version);
    CLIENT_PRINT("%s", mbedtls_version);

    CLIENT_PRINT("My PID: %d", getpid());

    CLIENT_PRINT("PSA version: %u", psa_version(PSA_SID_CRYPTO_SID));
    handle = psa_connect(PSA_SID_CRYPTO_SID, 1);

    if (handle < 0) {
        CLIENT_PRINT("Couldn't connect %d", handle);
        return PSA_ERROR_COMMUNICATION_FAILURE;
    }

    int ok = psa_crypto_call(PSA_CRYPTO_INIT, NULL, 0, &result, &result_length);
    CLIENT_PRINT("PSA_CRYPTO_INIT returned: %d", ok);

    if (!ok) {
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

fail:
    free(result);

    return status;
}

void mbedtls_psa_crypto_free(void)
{
    CLIENT_PRINT("Closing handle");
    psa_close(handle);
    handle = -1;
}


psa_status_t psa_hash_abort(
    psa_hash_operation_t *operation
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_hash_operation_t_needs(*operation);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *operation);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_ABORT,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_hash_operation_t(&rpos, &rremain, operation);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_clone(
    const psa_hash_operation_t *source_operation,
    psa_hash_operation_t *target_operation
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_hash_operation_t_needs(*source_operation) +
                    psasim_serialise_psa_hash_operation_t_needs(*target_operation);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *source_operation);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *target_operation);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_CLONE,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_hash_operation_t(&rpos, &rremain, target_operation);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_compare(
    psa_algorithm_t alg,
    const uint8_t *input, size_t  input_length,
    const uint8_t *hash, size_t  hash_length
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_algorithm_t_needs(alg) +
                    psasim_serialise_buffer_needs(input, input_length) +
                    psasim_serialise_buffer_needs(hash, hash_length);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_algorithm_t(&pos, &remaining, alg);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, input, input_length);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, hash, hash_length);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_COMPARE,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_compute(
    psa_algorithm_t alg,
    const uint8_t *input, size_t  input_length,
    uint8_t *hash, size_t  hash_size,
    size_t *hash_length
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_algorithm_t_needs(alg) +
                    psasim_serialise_buffer_needs(input, input_length) +
                    psasim_serialise_buffer_needs(hash, hash_size) +
                    psasim_serialise_size_t_needs(*hash_length);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_algorithm_t(&pos, &remaining, alg);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, input, input_length);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, hash, hash_size);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_size_t(&pos, &remaining, *hash_length);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_COMPUTE,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_return_buffer(&rpos, &rremain, hash, hash_size);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_size_t(&rpos, &rremain, hash_length);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_finish(
    psa_hash_operation_t *operation,
    uint8_t *hash, size_t  hash_size,
    size_t *hash_length
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_hash_operation_t_needs(*operation) +
                    psasim_serialise_buffer_needs(hash, hash_size) +
                    psasim_serialise_size_t_needs(*hash_length);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *operation);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, hash, hash_size);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_size_t(&pos, &remaining, *hash_length);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_FINISH,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_hash_operation_t(&rpos, &rremain, operation);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_return_buffer(&rpos, &rremain, hash, hash_size);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_size_t(&rpos, &rremain, hash_length);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_setup(
    psa_hash_operation_t *operation,
    psa_algorithm_t alg
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_hash_operation_t_needs(*operation) +
                    psasim_serialise_psa_algorithm_t_needs(alg);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *operation);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_algorithm_t(&pos, &remaining, alg);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_SETUP,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_hash_operation_t(&rpos, &rremain, operation);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_update(
    psa_hash_operation_t *operation,
    const uint8_t *input, size_t  input_length
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_hash_operation_t_needs(*operation) +
                    psasim_serialise_buffer_needs(input, input_length);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *operation);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, input, input_length);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_UPDATE,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_hash_operation_t(&rpos, &rremain, operation);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}


psa_status_t psa_hash_verify(
    psa_hash_operation_t *operation,
    const uint8_t *hash, size_t  hash_length
    )
{
    uint8_t *params = NULL;
    uint8_t *result = NULL;
    size_t result_length;
    psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

    size_t needed = psasim_serialise_begin_needs() +
                    psasim_serialise_psa_hash_operation_t_needs(*operation) +
                    psasim_serialise_buffer_needs(hash, hash_length);

    params = malloc(needed);
    if (params == NULL) {
        status = PSA_ERROR_INSUFFICIENT_MEMORY;
        goto fail;
    }

    uint8_t *pos = params;
    size_t remaining = needed;
    int ok;
    ok = psasim_serialise_begin(&pos, &remaining);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_psa_hash_operation_t(&pos, &remaining, *operation);
    if (!ok) {
        goto fail;
    }
    ok = psasim_serialise_buffer(&pos, &remaining, hash, hash_length);
    if (!ok) {
        goto fail;
    }

    ok = psa_crypto_call(PSA_HASH_VERIFY,
                         params, (size_t) (pos - params), &result, &result_length);
    if (!ok) {
        printf("XXX server call failed\n");
        goto fail;
    }

    uint8_t *rpos = result;
    size_t rremain = result_length;

    ok = psasim_deserialise_begin(&rpos, &rremain);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_status_t(&rpos, &rremain, &status);
    if (!ok) {
        goto fail;
    }

    ok = psasim_deserialise_psa_hash_operation_t(&rpos, &rremain, operation);
    if (!ok) {
        goto fail;
    }

fail:
    free(params);
    free(result);

    return status;
}
