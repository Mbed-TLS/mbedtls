
/*
 * TODO: Test second argument in mbedtls_reader_reclaim!
 */

/* BEGIN_HEADER */

#include <stdlib.h>
#include "../include/mbedtls/mps/reader.h"
#include "../include/mbedtls/mps/writer.h"

/*
 * Compile-time configuration for test suite.
 */

/* Comment/Uncomment this to disable/enable the
 * testing of the various MPS layers.
 * This can be useful for time-consuming instrumentation
 * tasks such as the conversion of E-ACSL annotations
 * into runtime assertions. */
#define TEST_SUITE_MPS_READER
#define TEST_SUITE_MPS_WRITER

/* End of compile-time configuration. */

/* END_HEADER */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_feed_empty( int option )
{
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    switch( option )
    {
        case 0: /* NULL buffer */
            TEST_ASSERT( mbedtls_reader_feed( &rd, NULL, sizeof( buf ) ) ==
                         MBEDTLS_ERR_READER_INVALID_ARG );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    /* Subsequent feed-calls should still succeed. */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );

    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_single_round( int with_acc )
{
    /* The most basic use case: lower layer provides a buffer,
      * upper layer fetches it in a single go. */
    unsigned char bufA[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_multiple_rounds( int with_acc )
{
    /* Test multiple rounds of the lower layer providing data
     * and the upper layer fetching it in a single go. */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_single_round( int with_acc )
{
    /* Lower layer provides data that the upper layer fully consumes
     * through multiple `get` calls. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 10, 70 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    TEST_ASSERT( memcmp( tmp, buf + 80, 20 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_multiple_rounds( int with_acc )
{
    /* Repeat "Lower layer provides data the the upper layer fully
     * consumes through multiple `get` calls" multiple times. */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 10, 70 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_disabled()
{
    /* If read-request goes beyond current read buffer
     * and pausing is not used, expected OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_NEED_ACCUMULATOR );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_buffer_too_small()
{
    /* If read-request goes beyond current read buffer
     * and pausing is used but the pause buffer is too small,
     * expect failure in the subsequent reclaim. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_multiple_pausing( int option )
{
    unsigned char bufA[100], bufB[20], bufC[10];
    unsigned char *tmp;
    unsigned char acc[50];
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);
    for( int i=0; (unsigned) i < sizeof( bufC ); i++ )
        bufC[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    switch( option )
    {
        case 0: /* Fetch same chunks, commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * large enough. */

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, &tmp_len ) == 0 );
            TEST_ASSERT( tmp_len == 10 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufC, sizeof( bufC ) ) == 0 );;

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufB + 10, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufC, 10 ) == 0 );
            break;

        case 1: /* Fetch same chunks, commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * not large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 51, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                         MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
            break;

        case 2: /* Fetch same chunks, don't commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufC, sizeof( bufC ) ) == 0 );;

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 40, bufC, 10 ) == 0 );
            break;

        case 3: /* Fetch same chunks, don't commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * not large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 21, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                         MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_reclaim_data_left( int option )
{
    /* Attempt to reclaim when the higher layer
     * hasn't fully consumed the buffer. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );

    /* Consumption (upper layer) */
    switch( option )
    {
        case 0:
            /* Fetch (but not commit) the entire buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ), &tmp, NULL )
                         == 0 );
            TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
            break;

        case 1:
            /* Fetch (but not commit) parts of the buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf, sizeof( buf ) / 2 ) == 0 );
            break;

        case 2:
            /* Fetch and commit parts of the buffer, then
             * fetch but not commit the rest of the buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf, sizeof( buf ) / 2 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf + sizeof( buf ) / 2,
                                 sizeof( buf ) / 2 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_DATA_LEFT );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_reclaim_data_left_retry()
{
    /* Lower layer attempts to reclaim but finds that data
     * remains to be consumed and hence passes the reader
     * back to upper layer who continues processing. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;

    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 50, 50 ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_DATA_LEFT );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 50, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    switch( option )
    {
        case 0:  /* Single uncommited fetch at pausing */
        case 1:
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;
        default: /* Multiple uncommitted fetches at pausing */
            break;
    }
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    /* Consumption */
    switch( option )
    {
        case 0: /* Single fetch at pausing, re-fetch with commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 1: /* Single fetch at pausing, re-fetch without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 2: /* Multiple fetches at pausing, repeat without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 3: /* Multiple fetches at pausing, repeat with commit 1. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 4: /* Multiple fetches at pausing, repeat with commit 2. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 5: /* Multiple fetches at pausing, repeat with commit 3. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
    }

    /* In all cases, fetch the rest of the second buffer. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB + 10, 90 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_multiple_feeds( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[70];
    mbedtls_reader rd;
    size_t fetch_len;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* 20 left, ask for 70 -> 50 overhead */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    switch( option )
    {
        case 0: /* 10 + 10 + 80 byte feed */
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 10 ) ==
                         MBEDTLS_ERR_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 10, 10 ) ==
                         MBEDTLS_ERR_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 20, 80 ) == 0 );
            break;

        case 1: /* 50 x 1byte */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 1 ) == 0 );
            break;

        case 2: /* 49 x 1byte + 51bytes */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 51 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
    TEST_ASSERT( memcmp( tmp + 20, bufB, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 1000, &tmp, &fetch_len ) == 0 );
    switch( option )
    {
        case 0:
            TEST_ASSERT( fetch_len == 50 );
            break;

        case 1:
            TEST_ASSERT( fetch_len == 0 );
            break;

        case 2:
            TEST_ASSERT( fetch_len == 50 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_commit_in_old()
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 5 ) ==
                 MBEDTLS_ERR_READER_NEED_MORE );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 5, 3 ) ==
                 MBEDTLS_ERR_READER_NEED_MORE );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 8, sizeof( bufB ) - 8 ) ==
                 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
    TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_reader_inconsistent_usage( int option)
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    int success = 0;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_reader_init( &rd, acc, sizeof( acc ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    switch( option )
    {
        case 0:
            /* Ask for buffered data in a single chunk, no commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 1:
            /* Ask for buffered data in a single chunk, with commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        case 2:
            /* Ask for more than was requested when pausing, #1 */
            TEST_ASSERT( mbedtls_reader_get( &rd, 31, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 3:
            /* Ask for more than was requested when pausing #2 */
            TEST_ASSERT( mbedtls_reader_get( &rd, (unsigned) -1, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 4:
            /* Asking for buffered data in different
             * chunks than before CAN fail. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 5:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - no commits */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 6:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - intermediate commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 7:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - end commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        case 8:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - intermediate & end commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    if( success == 1 )
    {
        /* In all succeeding cases, fetch the rest of the second buffer. */
        TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
        TEST_ASSERT( memcmp( tmp, bufB + 10, 90 ) == 0 );
        TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

        /* Wrapup */
        TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    }

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_random_usage( int num_out_chunks,
                                      int max_chunk_size,
                                      int max_request,
                                      int acc_size )

{
    /* Randomly pass a reader object back and forth between lower and
     * upper layer and let each of them call the respective reader API
     * functions in a random fashion.
     *
     * On the lower layer, we're tracking and concatenating
     * the data passed to successful feed calls.
     *
     * For the upper layer, we track and concatenate buffers
     * obtained from successful get calls.
     *
     * As long as the lower layer calls reclaim at least once, (resetting the
     * fetched but not-yet-committed data), this should always lead to the same
     * stream of outgoing/incoming data for the lower/upper layers, even if
     * most of the random calls fail.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */
    int ret;
    unsigned char *acc = NULL;
    unsigned char *outgoing, *incoming;
    unsigned char *cur_chunk = NULL;
    size_t cur_out_chunk, out_pos, in_commit, in_fetch;
    int rand_op;  /* Lower layer:
                   * - Reclaim (0)
                   * - Feed (1)
                   * Upper layer:
                   * - Get, do tolerate smaller output (0)
                   * - Get, don't tolerate smaller output (1)
                   * - Commit (2) */
    int mode = 0; /* Lower layer (0) or Upper layer (1) */
    int reclaimed = 1; /* Have to call reclaim at least once before
                        * returning the reader to the upper layer. */
    mbedtls_reader rd;

    if( acc_size > 0 )
    {
        acc = malloc( acc_size );
        TEST_ASSERT( acc != NULL );
    }

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
//    srand( time( NULL ) );

    outgoing = malloc( num_out_chunks * max_chunk_size );
    incoming = malloc( num_out_chunks * max_chunk_size );
    TEST_ASSERT( outgoing != NULL );
    TEST_ASSERT( incoming != NULL );

    TEST_ASSERT( mbedtls_reader_init( &rd, acc, acc_size ) == 0 );

    cur_out_chunk = 0;
    in_commit = 0;
    in_fetch = 0;
    out_pos = 0;
    while( cur_out_chunk < (unsigned) num_out_chunks )
    {
        if( mode == 0 )
        {
            /* Choose randomly between reclaim and feed */
            rand_op = rand() % 2;

            if( rand_op == 0 )
            {
                /* Reclaim */
                ret = mbedtls_reader_reclaim( &rd, NULL );

                if( ret == 0 )
                {
                    TEST_ASSERT( cur_chunk != NULL );
                    free( cur_chunk );
                    cur_chunk = NULL;
                }
                reclaimed = 1;
            }
            else
            {
                /* Feed reader with a random chunk */
                unsigned char *tmp;
                size_t tmp_size;
                if( cur_out_chunk == (unsigned) num_out_chunks )
                    continue;

                tmp_size = ( rand() % max_chunk_size ) + 1;
                tmp = malloc( tmp_size );
                TEST_ASSERT( tmp != NULL );

                TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, tmp, tmp_size ) == 0 );
                ret = mbedtls_reader_feed( &rd, tmp, tmp_size );

                if( ret == 0 || ret == MBEDTLS_ERR_READER_NEED_MORE )
                {
                    cur_out_chunk++;
                    memcpy( outgoing + out_pos, tmp, tmp_size );
                    out_pos += tmp_size;
                }

                if( ret == 0 )
                {
                    TEST_ASSERT( cur_chunk == NULL );
                    cur_chunk = tmp;
                }
                else
                {
                    free( tmp );
                }

            }

            /* Randomly switch to consumption mode if reclaim
             * was called at least once. */
            if( reclaimed == 1 && rand() % 3 == 0 )
            {
                in_fetch = 0;
                mode = 1;
            }
        }
        else
        {
            /* Choose randomly between get tolerating fewer data,
             * get not tolerating fewer data, and commit. */
            rand_op = rand() % 3;
            if( rand_op == 0 || rand_op == 1 )
            {
                size_t get_size, real_size;
                unsigned char *chunk_get;
                get_size = ( rand() % max_request ) + 1;
                if( rand_op == 0 )
                {
                    ret = mbedtls_reader_get( &rd, get_size, &chunk_get,
                                              &real_size );
                }
                else
                {
                    real_size = get_size;
                    ret = mbedtls_reader_get( &rd, get_size, &chunk_get, NULL );
                }

                /* Check if output is in accordance with what was written */
                if( ret == 0 )
                {
                    memcpy( incoming + in_commit + in_fetch,
                            chunk_get, real_size );
                    TEST_ASSERT( memcmp( incoming + in_commit + in_fetch,
                                         outgoing + in_commit + in_fetch,
                                         real_size ) == 0 );
                    in_fetch += real_size;
                }
            }
            else if( rand_op == 2 ) /* Commit */
            {
                ret = mbedtls_reader_commit( &rd );
                if( ret == 0 )
                {
                    in_commit += in_fetch;
                    in_fetch = 0;
                }
            }

            /* Randomly switch back to preparation */
            if( rand() % 3 == 0 )
            {
                reclaimed = 0;
                mode = 0;
            }
        }
    }

    /* Cleanup */
    TEST_ASSERT( mbedtls_reader_free( &rd ) == 0 );
    free( incoming );
    free( outgoing );
    free( acc );
    free( cur_chunk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_basic( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;
    size_t tmp_sz;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    /* Do actual fetching */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 101, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );

    /* ([C]ommit, [F]etch) = (0,0) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 50, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,50) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,60) */
    TEST_ASSERT( mbedtls_reader_commit_ext( &rd_ext ) == 0 );
    /* Now (C,F) = (60,60) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 41, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    /* Now (C,F) = (60,60) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 40,
                                         &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 15 );
    /* Now (C,F) = (60,75) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 26, &tmp, &tmp_sz ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 25, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 25, &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 0 );
    /* Now still (C,F) = (60,75) */

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_group_open_close( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;
    size_t tmp_sz;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    /* Do actual fetching */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 101, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );

    /* ([C]ommit, [F]etch) = (0,0) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 50, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,50) */
    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 51 ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 20 ) == 0 );
    /* Now (C,F) have a sub-group in the range from 50-70 */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 21, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,60) */
    /* Cannot close group yet */
    TEST_ASSERT( mbedtls_reader_group_close( &rd_ext ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,70) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_group_close( &rd_ext ) == 0 );
    /* Now only open group is 0-100 again */
    TEST_ASSERT( mbedtls_reader_commit_ext( &rd_ext ) == 0 );
    /* Now (C,F) = (70,70) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) == 0 );
    /* Now (C,F) = (70,71) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 30, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 29, &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 4 );
    /* Now (C,F) = (70, 75) */

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_many_groups( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_init( &rd, NULL, 0 ) == 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    for( size_t cur_grp=1; cur_grp < MBEDTLS_READER_MAX_GROUPS; cur_grp++ )
    {
        TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 100 - 2 * cur_grp + 3,
                                             &tmp, NULL ) ==
                     MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
        TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) == 0 );
        TEST_ASSERT( mbedtls_reader_group_open( &rd_ext,
                                                100 - 2 * ( cur_grp - 1 ) ) ==
                     MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
        TEST_ASSERT( mbedtls_reader_group_open( &rd_ext,
                                                100 - 2 * cur_grp ) == 0 );
    }

    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 1 ) ==
                 MBEDTLS_ERR_READER_TOO_MANY_GROUPS );

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_feed_empty( int option )
{
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    switch( option )
    {
        case 0: /* NULL buffer */
            TEST_ASSERT( mbedtls_writer_feed( &wr, NULL, 0 ) ==
                         MBEDTLS_ERR_WRITER_INVALID_ARG );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    /* Subsequent feed-calls should still succeed. */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_single_step_single_round( int with_queue )
{
    /* The most basic use case: lower layer provides space
     * for outgoing data to be written to, and upper layer
     * fetches and writes it in a single go. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;

    for( int i=0; (unsigned) i < 100; i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    /* Can't reclaim as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Feed some buffer to the writer */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Can't feed again as we're now in producing mode */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Producing (upper layer) */
    /* Fetch and write to the entire output buffer */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );

    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );

    TEST_ASSERT( memcmp( buf, out, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_unexpected_operations()
{
    /* Unexpected operations shouldn't corrupt any internal structures.
     * This test checks this by exercising a simple writer test with
     * queueing and inserting multiple unexpected calls in between. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_mps_size_t olen;
    mbedtls_writer wr;

    for( int i=0; (unsigned) i < 100; i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < 100; i++ )
        outB[i] = ~ (unsigned char) i;

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    /* Can't reclaim as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Can't get or commit anything as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Feed some buffer to the writer */
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Can't feed again as we're now in producing mode */
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Test the committing again has no effect. */
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Test the committing again has no effect. */
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, &olen, NULL, 0 ) == 0 );
    TEST_ASSERT( olen == 100 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Providing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, &olen, NULL, 0 ) == 0 );
    TEST_ASSERT( olen == 100 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );

    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_single_step_multiple_rounds( int with_queue )
{
    /* Multiple rounds of lower layer providing space
     * for outgoing data to be written to, and upper layer
     * fetches and writes it in a single go. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );

    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_single_round( int with_queue )
{
    /* Lower layer provides output buffer that the upper layer
     * fetches and writes to in multiple `get` calls. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, out + 10, 70 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, out + 80, 20 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );

    TEST_ASSERT( memcmp( buf, out, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_multiple_rounds( int with_queue )
{
    /* Repeat lower layer providing output buffer that the upper layer
     * fetches and writes to in multiple `get` calls. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 10, 70 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, outA + 80, 20 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );

    TEST_ASSERT( memcmp( outA, bufA, 100 ) == 0 );
    TEST_ASSERT( memcmp( outB, bufB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_multiple_rounds_partial_commit( int with_queue )
{
    /* Almost identical to multiple_steps_multiple_rounds_no_commit,
     * but only partially comitting writes in first round. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    else
        TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 10, 70 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, outA + 80, 20 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 1 /*force*/ ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );

    TEST_ASSERT( memcmp( outA, bufA, 80  ) == 0 );
    TEST_ASSERT( memcmp( outB, bufB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_needed_disabled()
{
    /* If a write request goes beyond the provided output buffer
     * and queueing is not used, signal OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 50, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 50 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_DATA_LEFT );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( buf, out, 50 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_needed_too_small()
{
    /* If a write request goes beyond the provided output buffer
     * and queueing is used but the queue is too small, signal OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 50, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 50 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_DATA_LEFT );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( buf, out, 50 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_basic( int commit )
{
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    if( commit == 1 )
        TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_boundary()
{
    /* This test exercises the behavior of the writer
     * when a write-request is made after the entire
     * output buffer has been requested and committed.
     * There are two ways to handle this in the implementation:
     * 1. Reject the request, indicating that not enough data is available.
     * 2. Attempt to serve the request from the accumulator.
     * Currently, the implementation follows behavior 2,
     * and the test checks for that. */

    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];

    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, sizeof( bufA ), &tmp, NULL ) == 0 );
    memcpy( tmp, outA, sizeof( bufA ) );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* In behavior 2, the following write-request
     * will be served from the queue. */
    TEST_ASSERT( mbedtls_writer_get( &wr, sizeof( queue ), &tmp, NULL ) == 0 );
    memcpy( tmp, outB, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 1, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 1 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( bufA, outA, sizeof( bufA ) ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, sizeof( queue ) ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_requests( int commit )
{
    /* This test exercises the behavior of the writer
     * when multiple requests are served from the queue. */

    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[40];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    if( commit )
        TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 80, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 20, 80 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_refeed()
{
    /* Test situation where multiple output buffers are
     * needed to hold the queued outbound data. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
    {
        bufA[i] = 0;
        outA[i] = (unsigned char) i;
    }
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
    {
        bufB[i] = 0;
        outB[i] = ~ ((unsigned char) i);
    }

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    /* So far we have been writing to the queue, and the results
     * are not partially copied to the output buffer until the buffer is reclaimed. */
    TEST_ASSERT( memcmp( bufA, outA, 100 ) != 0 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    /* Now they should be there. */
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    for( int i=0; i<9; i++ )
    {
        TEST_ASSERT( mbedtls_writer_feed( &wr, bufB + i, 1 ) ==
                     MBEDTLS_ERR_WRITER_NEED_MORE );
    }
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB + 9, 91 ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_rounds()
{
    /* Exercise three rounds of feed-get-commit-reclaim, with queueing*/
    unsigned char bufA[100], bufB[100], bufC[100];
    unsigned char outA[100], outB[100], outC[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);
    for( int i=0; (unsigned) i < sizeof( outC ); i++ )
        outC[i] = (unsigned char)( 128 + i );

    /* Provisioning (lower layer) */
    TEST_ASSERT( mbedtls_writer_init( &wr, queue, sizeof( queue ) ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 80, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 80 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 90, 10 );
    memcpy( tmp + 10, outC, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufC, sizeof( bufC ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outC + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufC, outC, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_random_usage( int data_amount,
                                      int max_chunk_size,
                                      int max_request,
                                      int queue_size )

{
    /* Randomly pass a writer object back and forth between lower and
     * upper layer and let each of them call the respective writer API
     * functions in a random fashion.
     *
     * On the lower layer, we're tracking and concatenating
     * the data passed to successful reclaim calls.
     *
     * For the upper layer, we track and concatenate buffers
     * obtained from successful commit calls.
     *
     * As long as the lower layer calls reclaim at least once, (resetting the
     * fetched but not-yet-committed data), this should always lead to the same
     * stream of outgoing/incoming data for the lower/upper layers, even if
     * most of the random calls fail.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */
    int ret;
    unsigned char *queue = NULL;
    unsigned char *outgoing, *incoming;
    unsigned char *cur_chunk = NULL;
    mbedtls_mps_size_t cur_out_chunk_size, out_pos, in_commit, in_fetch;
    int rand_op;  /* Lower layer:
                   * - Reclaim (0)
                   * - Feed (1)
                   * Upper layer:
                   * - Get, do tolerate smaller output (0)
                   * - Get, don't tolerate smaller output (1)
                   * - Commit (2) */
    int mode = 0; /* Lower layer (0) or Upper layer (1) */
    int reclaimed = 1; /* Have to call reclaim at least once before
                        * returning the reader to the upper layer. */
    int force;
    mbedtls_writer wr;

    unsigned seed;

    if( queue_size > 0 )
    {
        queue = malloc( queue_size );
        TEST_ASSERT( queue != NULL );
    }

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
    seed = time( NULL ); // 1522933016;
    srand( seed );

    outgoing = malloc( data_amount );
    incoming = malloc( data_amount );

    TEST_ASSERT( outgoing != NULL );
    TEST_ASSERT( incoming != NULL );

    TEST_ASSERT( mbedtls_writer_init( &wr, queue, queue_size ) == 0 );

    cur_out_chunk_size = 0;
    in_commit = 0;
    in_fetch = 0;
    out_pos = 0;
    while( out_pos < (unsigned) data_amount )
    {
        if( mode == 0 )
        {
            /* Choose randomly between reclaim and feed */
            rand_op = rand() % 3;

            if( rand_op == 0 || rand_op == 1 )
            {
                mbedtls_mps_size_t out_committed;

                /* Reclaim */

                if( cur_out_chunk_size > out_pos - (unsigned) data_amount )
                    force = 1;
                else
                    force = ( rand_op == 0 );

                if( force == 1 )
                {
                    ret = mbedtls_writer_reclaim( &wr, &out_committed,
                                                  NULL, 1 );
                }
                else
                {
                    ret = mbedtls_writer_reclaim( &wr, NULL, NULL, 0 );
                    out_committed = cur_out_chunk_size;
                }

                TEST_ASSERT( ! ( force == 1 &&
                                 ret == MBEDTLS_ERR_WRITER_DATA_LEFT ) );

                if( ret == 0 )
                {
                    TEST_ASSERT( out_committed <= cur_out_chunk_size );
                    TEST_ASSERT( cur_chunk != NULL );
                    memcpy( outgoing + out_pos, cur_chunk, out_committed );
                    out_pos += out_committed;

                    free( cur_chunk );
                    cur_chunk = NULL;
                }
                reclaimed = 1;
            }
            else
            {
                /* Feed writer another outgoing data chunk */
                unsigned char *tmp;
                mbedtls_mps_size_t tmp_size;

                tmp_size = ( rand() % max_chunk_size ) + 1;
                tmp = malloc( tmp_size );
                TEST_ASSERT( tmp != NULL );

                ret = mbedtls_writer_feed( &wr, tmp, tmp_size );

                if( ret == MBEDTLS_ERR_WRITER_NEED_MORE )
                {
                    /* Outgoing data chunk has been entirely written
                     * from the queue. */
                    memcpy( outgoing + out_pos, tmp, tmp_size );
                    out_pos += tmp_size;
                }

                if( ret == 0 )
                {
                    cur_chunk = tmp;
                    cur_out_chunk_size = tmp_size;
                }
                else
                {
                    free( tmp );
                }
            }

            /* Randomly switch to consumption mode if reclaim
             * was called at least once. */
            if( reclaimed == 1 && rand() % 3 == 0 )
            {
                in_fetch = 0;
                mode = 1;
            }
        }
        else
        {
            /* Choose randomly between get tolerating fewer data,
             * get not tolerating fewer data, and commit. */
            rand_op = rand() % 3;
            if( rand_op == 0 || rand_op == 1 )
            {
                mbedtls_mps_size_t get_size, real_size;
                unsigned char *chunk_get;
                get_size = ( rand() % max_request ) + 1;
                if( get_size > data_amount - ( in_commit + in_fetch ) )
                    get_size = data_amount - in_commit - in_fetch;

                if( rand_op == 0 )
                {
                    ret = mbedtls_writer_get( &wr, get_size, &chunk_get,
                                              &real_size );
                }
                else
                {
                    real_size = get_size;
                    ret = mbedtls_writer_get( &wr, get_size, &chunk_get, NULL );
                }

                if( ret == 0 )
                {
                    /* Fill output buffer with random data. */
                    mbedtls_test_rnd_std_rand( NULL, incoming + in_commit + in_fetch, real_size );
                    memcpy( chunk_get, incoming + in_commit + in_fetch, real_size );
                    in_fetch += real_size;
                }
                else if( ret == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                {
                    TEST_ASSERT( (mbedtls_mps_size_t)( in_commit + in_fetch + get_size ) >
                                 (mbedtls_mps_size_t) queue_size );
                }
            }
            else if( rand_op == 2 ) /* Commit */
            {
                mbedtls_mps_size_t omit=0;

                /* Leave a change to omit more than what was
                 * fetched since the last commit. */
                omit = rand() % ( 2 * in_fetch + 1 );

                ret = mbedtls_writer_commit_partial( &wr, omit );
                if( omit > in_fetch )
                    TEST_ASSERT( ret ==  MBEDTLS_ERR_WRITER_INVALID_ARG );

                if( ret == 0 )
                {
                    in_commit += in_fetch - omit;
                    in_fetch = 0;
                }
            }

            /* Randomly switch back to preparation */
            if( rand() % 3 == 0 )
            {
                reclaimed = 0;
                mode = 0;
            }
        }
    }

    /* Compare results. */
    TEST_ASSERT( in_commit == (unsigned) data_amount );
    TEST_ASSERT( memcmp( outgoing, incoming, data_amount ) == 0 );

    /* Cleanup */
    TEST_ASSERT( mbedtls_writer_free( &wr ) == 0 );
    free( incoming );
    free( outgoing );
    free( queue );
    free( cur_chunk );
}
/* END_CASE */
