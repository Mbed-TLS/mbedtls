
/*
 * TODO: Test second argument in mbedtls_reader_reclaim!
 */

/* BEGIN_HEADER */

#include <stdlib.h>
#include "../include/mbedtls/mps/allocator.h"
#include "../include/mbedtls/mps/reader.h"
#include "../include/mbedtls/mps/writer.h"
#include "../include/mbedtls/mps/layer1.h"
#include "../include/mbedtls/mps/layer2.h"
#include "../include/mbedtls/mps/layer3.h"
#include "../include/mbedtls/mps/mps.h"

/*
 * Compile-time configuration for test suite.
 */

/* Comment/Uncomment this to disable/enable the
 * testing of the various MPS layers.
 * This can be useful for time-consuming instrumentation
 * tasks such as the conversion of E-ACSL annotations
 * into runtime assertions. */
#define TEST_SUITE_MPS_READER
#define TEST_SUITE_MPS_WRITER
#define TEST_SUITE_MPS_L1
#define TEST_SUITE_MPS_L2
#define TEST_SUITE_MPS_L3
#define TEST_SUITE_MPS_L4

/* Comment/Uncomment this to disable/enable the testing
 * of the production SSL record transformations as implemented
 * in ssl_decrypt_buf and ssl_encrypt_buf.
 *
 * Apart from this dependency, the MPS is entirely
 * independent of the rest of Mbed TLS and this suite
 * can be run standalone. */
//#define TEST_SUITE_MPS_NO_SSL

/* The sizes of the accumulator/queue used by the
 * readers/writers in Layer 2.
 *
 * These are passed as `max_read` and `max_write`
 * in `l2_init()`; see the documentation of the latter
 * for how they manifest as semantic guarantees on
 * the Layer 2 API boundary.
 */
#define L2_DEFAULT_ACCUMULATOR_SIZE 100
#define L2_DEFAULT_QUEUE_SIZE       10

/* End of compile-time configuration. */

#if !defined(TEST_SUITE_MPS_NO_SSL)
#include "../include/mbedtls/ssl_internal.h"
#endif

/* Currently, the real record transformation functions
 * ssl_decrypt_buf and ssl_encrypt_buf use debugging macros
 * which depend on a properly configured SSL context
 * to be setup. Currently, we don't setup such a context
 * here, hence we cannot use real transforms if DEBUG_C
 * is set. */
#if !defined(TEST_SUITE_MPS_NO_SSL) && defined(MBEDTLS_DEBUG_C)
#error Real record transformations can only be tested without MBEDTLS_DEBUG_C!
#endif

/*
 *
 * Helper structures for Layer 1 testing
 *
 * Layer 1 interfaces with the following components:
 * (1) An allocator providing the read and write buffers
 *     that the Layer 1 implementation uses when interfacing
 *     with the underlying transport (the interface for which
 *     does currently not allow in-place operations).
 * (2) The underlying stream or datagram transport (Layer 0).
 *
 */

/*
 * Mock object for a Layer 0 stream transport
 */

static size_t layer0_bufsize = 42;
typedef struct
{
    unsigned char *buf;
    size_t buflen;
    size_t avail;
} layer0_mock;

static layer0_mock c2s; /* Client-to-Server */
static layer0_mock s2c; /* Server-to-Client */

int layer0_init( layer0_mock *mbuf )
{
    mbuf->buf = malloc( layer0_bufsize );
    if( mbuf->buf == NULL )
        return( -1 );

    mbuf->avail = 0;
    mbuf->buflen = layer0_bufsize;
    return( 0 );
}

void layer0_free( layer0_mock *mbuf )
{
    if( mbuf->buf != NULL )
        free( mbuf->buf );
}

/* Read size bytes from mbuf into dst */
int layer0_read( layer0_mock* const mbuf, unsigned char *dst,
                 unsigned long size )
{
    size_t remaining;

    if( mbuf->avail == 0 )
        return( MPS_ERR_WANT_READ );

    if( size > mbuf->avail )
        size = mbuf->avail;

    /* Return only a part of the available buffer
     * to test how the upper layers deal with it. */
    size = ( size * ( ( rand() % 100 ) + 1 ) ) / 100;
    if( size == 0 )
        size = 1;
    remaining = mbuf->avail - size;

    memcpy( dst, mbuf->buf, size );
    memmove( mbuf->buf, mbuf->buf + size, remaining );

    mbuf->avail = remaining;
    return( size );
}

/* Write size bytes from src into mbuf */
int layer0_write( layer0_mock* const mbuf, const unsigned char *src,
                  size_t size )
{
    const size_t remaining = mbuf->buflen - mbuf->avail;

    if( size == 0 )
        return( 0 );

    if( remaining == 0 )
        return( MPS_ERR_WANT_WRITE );

    if( size > remaining )
        size = remaining;

    /* Return only a part of the available buffer
     * to test how the upper layers deal with it. */
    size = ( size * ( ( rand() % 100 ) + 1 ) ) / 100;
    if( size == 0 )
        size = 1;

    memcpy( mbuf->buf + mbuf->avail, src, size );
    mbuf->avail += size;

    return( size );
}

/* Write size bytes from src into the server to client buffer */
int layer0_write_srv( const unsigned char *src, size_t size )
{
    return layer0_write( &s2c, src, size );
}

/* Write size bytes from src into the client to server buffer */
int layer0_write_cli( const unsigned char *src, size_t size )
{
    return layer0_write( &c2s, src, size );
}

/* Read size bytes from the client to server buffer into dst */
int layer0_read_srv( unsigned char *dst, unsigned long size )
{
    return layer0_read( &c2s, dst, size );
}

/* Read size bytes from the server to client buffer into dst */
int layer0_read_cli( unsigned char *dst, unsigned long size )
{
    return layer0_read( &s2c, dst, size );
}

/*
 * Mock a Layer 0 datagram transport
 */

typedef struct
{
    unsigned char *buf;
    size_t buflen;
} layer0_dgram_mock_msg;

#define L0_MOCK_DGRAM_MAX_MSGS 1280

/* Simply a FIFO of instances of layer0_dgram_mock_msg */
typedef struct
{
    layer0_dgram_mock_msg msgs[ L0_MOCK_DGRAM_MAX_MSGS ];
    size_t read_pos;
    size_t write_pos;
} layer0_dgram_mock;

static layer0_dgram_mock c2s_d; /* Client-to-Server */
static layer0_dgram_mock s2c_d; /* Server-to-Client */

static void layer0_dgram_msg_free( layer0_dgram_mock_msg *msg )
{
    free( msg->buf );
    msg->buf = NULL;
    msg->buflen = 0;
}

static int layer0_dgram_msg_init( layer0_dgram_mock_msg *msg, size_t len )
{
    msg->buf = malloc( len );
    if( msg->buf == NULL )
        return( -1 );

    msg->buflen = len;
    return( 0 );
}

static int layer0_dgram_init( layer0_dgram_mock *ctx )
{
    layer0_dgram_mock_msg null_buf = { NULL, 0 };
    size_t idx;
    ctx->read_pos = 0;
    ctx->write_pos = 0;
    for( idx = 0; idx < L0_MOCK_DGRAM_MAX_MSGS; idx++ )
        ctx->msgs[idx] = null_buf;

    return( 0 );
}

static unsigned layer0_dgram_shift_idx( size_t idx, size_t shift )
{
    return( ( idx + shift ) % L0_MOCK_DGRAM_MAX_MSGS );
}

static void layer0_dgram_swap_dgrams( layer0_dgram_mock *ctx,
                                      size_t i, size_t j )
{
    layer0_dgram_mock_msg tmp;

    size_t idx_a = layer0_dgram_shift_idx( ctx->read_pos, i );
    size_t idx_b = layer0_dgram_shift_idx( ctx->read_pos, j );

    tmp = ctx->msgs[idx_a];
    ctx->msgs[idx_a] = ctx->msgs[idx_b];
    ctx->msgs[idx_b] = tmp;
}

static unsigned layer0_dgram_msg_available( layer0_dgram_mock *ctx )
{
    size_t write_pos = ctx->write_pos;
    size_t read_pos  = ctx->write_pos;
    if( write_pos >= read_pos )
        return( write_pos - read_pos );

    return( write_pos + ( L0_MOCK_DGRAM_MAX_MSGS - read_pos ) );
}

static void layer0_dgram_permute( layer0_dgram_mock *ctx,
                                  size_t transpositions )
{
    size_t const msg_avail = layer0_dgram_msg_available( ctx );
    size_t iter;

    if( msg_avail <= 1 )
        return;

    for( iter=0; iter < transpositions; iter++ )
    {
        size_t i, j;
        do
        {
            i = rand() % msg_avail;
            j = rand() % msg_avail;
        } while( i == j );

        printf( "L0 DGRAM MOCK: Swap %u <-> %u\n",
                (unsigned) i, (unsigned) j );
        layer0_dgram_swap_dgrams( ctx, i, j );
    }
}

static int layer0_dgram_free( layer0_dgram_mock *ctx )
{
    size_t idx;
    ctx->read_pos = 0;
    ctx->write_pos = 0;
    for( idx = 0; idx < L0_MOCK_DGRAM_MAX_MSGS; idx++ )
        layer0_dgram_msg_free( &ctx->msgs[ idx ] );

    return( 0 );
}

static size_t layer0_dgram_inc_idx( size_t idx )
{
    if( idx == L0_MOCK_DGRAM_MAX_MSGS - 1 )
        return( 0 );
    else
        return( idx + 1);
}

static int layer0_dgram_write( layer0_dgram_mock *ctx,
                               const unsigned char *src, size_t size )
{
    size_t write_pos     = ctx->write_pos;
    size_t read_pos      = ctx->read_pos;
    size_t new_write_pos = layer0_dgram_inc_idx( write_pos );

    printf( "Datagram write\n" );
    printf( "* Write position: %u\n", (unsigned) write_pos );
    printf( "* Read position:  %u\n", (unsigned) read_pos );
    printf( "* Datagram size:  %u\n", (unsigned) size );

    if( new_write_pos == read_pos )
        return( MPS_ERR_WANT_WRITE );

    layer0_dgram_msg_init( &ctx->msgs[write_pos], size );
    memcpy( ctx->msgs[write_pos].buf, src, size );

    ctx->write_pos = new_write_pos;
    return( (int) size );
}

static int layer0_dgram_read( layer0_dgram_mock *ctx,
                              unsigned char *dst, unsigned long size )
{
    size_t write_pos    = ctx->write_pos;
    size_t read_pos     = ctx->read_pos;
    size_t new_read_pos = layer0_dgram_inc_idx( read_pos );

    printf( "Datagram Read\n" );
    printf( "* Write position:  %u\n", (unsigned) write_pos );
    printf( "* Read position:   %u\n", (unsigned) read_pos );

    if( read_pos == write_pos )
    {
        printf( "No datagram available\n" );
        return( MPS_ERR_WANT_READ );
    }

    if( size > ctx->msgs[read_pos].buflen )
        size = ctx->msgs[read_pos].buflen;

    printf( "* Datagram length:    %u\n", (unsigned) ctx->msgs[read_pos].buflen );
    printf( "* Target buffer size: %u\n", (unsigned) size );

    memcpy( dst, ctx->msgs[read_pos].buf, size );
    layer0_dgram_msg_free( &ctx->msgs[read_pos] );

    ctx->read_pos = new_read_pos;
    return( (int) size );
}

/* Write size bytes from src into the server to client buffer */
int layer0_dgram_write_srv( const unsigned char *src, size_t size )
{
    return layer0_dgram_write( &s2c_d, src, size );
}

/* Write size bytes from src into the client to server buffer */
int layer0_dgram_write_cli( const unsigned char *src, size_t size )
{
    return layer0_dgram_write( &c2s_d, src, size );
}

/* Read size bytes from the client to server buffer into dst */
int layer0_dgram_read_srv( unsigned char *dst, unsigned long size )
{
    return layer0_dgram_read( &c2s_d, dst, size );
}

/* Read size bytes from the server to client buffer into dst */
int layer0_dgram_read_cli( unsigned char *dst, unsigned long size )
{
    return layer0_dgram_read( &s2c_d, dst, size );
}

/*
 * Timer mock object
 */

typedef struct
{
    uint32_t int_ms;
    uint32_t fin_ms;
} mock_timer_ctx;

static void set_mock_timer( void* mock_ctx, uint32_t int_ms,
                            uint32_t fin_ms )
{
    mock_timer_ctx *ctx = (mock_timer_ctx*) mock_ctx;
    printf( "Set mock timeout to %u / %u\n", int_ms, fin_ms );
    ctx->int_ms = int_ms;
    ctx->fin_ms = fin_ms;
}

static int get_mock_timer( void* mock_ctx )
{
    mock_timer_ctx *ctx = (mock_timer_ctx*) mock_ctx;
    if( ctx->int_ms > 0 )
        return( 2 );

    return( -1 );
}

/*
 *
 * Helper structures for Layer 2 testing
 *
 * Layer 2 interfaces with the following components:
 * (1) A layer 1 implementation
 * (2) An implementation of record payload protection
 * (2) Heap allocator: Currently, space for accumulators
 *     and queues are obtained by malloc/free -- at some
 *     point we might want to handle this through the
 *     the allocator that's also used by Layer 1.
 *
 * Currently, we have no Layer 1 mock object, so the
 * Layer 2 testing uses the production-implementation of
 * Layer 1.
 *
 * For record payload protection, we define a mock
 * implementation (not encrypting anything, but adding
 * some pre- and post-padding) to be able to test MPS
 * independently of the other parts of Mbed TLS.
 *
 */

/* This structure is used for Layer 2 random testing
 * and represents a typed chunk of data to be sent
 * and received through Layer 2. */
typedef struct
{
    uint8_t type;
    unsigned char *buf;
    size_t len;
    size_t send_progress;
    size_t read_progress;
} typed_data_chunk;

/*
 * Mock object for record payload protection
 *
 * This mock record transformation does the either nothing or the following:
 * 1. Add a fixed length 0-1-2-...-x-padding at the beginning of the plaintext.
 * 2. Add a random length 1-0-...-0-padding at the end of the plaintext.
 * 3. Add record sequence number and epoch at the beginning of the
 *    plaintext (after the pre-padding).
 */

typedef struct
{
    size_t enabled; /* 0: Do nothing, 1: Transform as described above */
    size_t pad;
} mbedtls_transform_mock_t;

/*
 * Transform multiplexing mock record payload protection
 * and real payload protection.
 */
struct mbedtls_mps_transform_t
{
    uint8_t type; /* 0: mock, 1: real */
    mbedtls_transform_mock_t mock;
#if !defined(TEST_SUITE_MPS_NO_SSL)
    mbedtls_ssl_transform real;
#endif
};

static void write_version( int major, int minor, int transport,
                           unsigned char ver[2] )
{
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
    {
        if( minor == MBEDTLS_SSL_MINOR_VERSION_2 )
            --minor; /* DTLS 1.0 stored as TLS 1.1 internally */

        ver[0] = (unsigned char)( 255 - ( major - 2 ) );
        ver[1] = (unsigned char)( 255 - ( minor - 1 ) );
    }
    else
#else
    ((void) transport);
#endif
    {
        ver[0] = (unsigned char) major;
        ver[1] = (unsigned char) minor;
    }
}

static void read_version( int *major, int *minor, int transport,
                          const unsigned char ver[2] )
{
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
    {
        *major = 255 - ver[0] + 2;
        *minor = 255 - ver[1] + 1;

        if( *minor == MBEDTLS_SSL_MINOR_VERSION_1 )
            ++*minor; /* DTLS 1.0 stored as TLS 1.1 internally */
    }
    else
#else
    ((void) transport);
#endif
    {
        *major = ver[0];
        *minor = ver[1];
    }
}

#define CHK( x )                                \
    do                                          \
    {                                           \
        if( !( x ) )                            \
            return( 1 );                        \
    } while( 0 )


/*
 * Create pairs of matching incoming/outgoing record transformations
 * given the type of cipher, the hash to use, as well as flags indicating
 * the use of Encrypt-Then-MAC, truncated authentication tags, and the
 * TLS version.
 */
#if !defined(TEST_SUITE_MPS_NO_SSL)
static int build_transforms( mbedtls_ssl_transform *t_in,
                             mbedtls_ssl_transform *t_out,
                             int cipher_type, int hash_id,
                             int etm, int tag_mode, int ver,
                             int (*f_rng)(void *, unsigned char *, size_t),
                             void *p_rng )
{
    mbedtls_cipher_info_t const *cipher_info;
    mbedtls_md_info_t const *md_info;

    size_t keylen, maclen, ivlen;
    unsigned char *key0, *key1, *md0, *md1;
    unsigned char iv_enc[16], iv_dec[16];

    /* Pick cipher */
    cipher_info = mbedtls_cipher_info_from_type( cipher_type );
    CHK( cipher_info != NULL );
    CHK( cipher_info->iv_size <= 16 );
    CHK( cipher_info->key_bitlen % 8 == 0 );

    /* Pick keys */
    keylen = cipher_info->key_bitlen / 8;
    CHK( ( key0 = malloc( keylen ) ) != NULL );
    CHK( ( key1 = malloc( keylen ) ) != NULL );

    f_rng( p_rng, key0, keylen );
    f_rng( p_rng, key1, keylen );

    /* Pick hash */
    md_info = mbedtls_md_info_from_type( hash_id );
    CHK( md_info != NULL );

    /* Pick hash keys */
    maclen = mbedtls_md_get_size( md_info );
    CHK( ( md0 = malloc( maclen ) ) != NULL );
    CHK( ( md1 = malloc( maclen ) ) != NULL );
    f_rng( p_rng, md0, maclen );
    f_rng( p_rng, md1, maclen );

    /* Pick IV's (regardless of whether they
     * are being used by the transform). */
    ivlen = cipher_info->iv_size;
    f_rng( p_rng, iv_enc, sizeof( iv_enc ) );
    f_rng( p_rng, iv_dec, sizeof( iv_dec ) );

    /*
     * Setup transforms
     */

    t_out->encrypt_then_mac = etm;
    t_in->encrypt_then_mac = etm;
    t_out->minor_ver = ver;
    t_in->minor_ver = ver;
    t_out->ivlen = ivlen; /* redundant, must be iv size */
    t_in->ivlen = ivlen;  /* redundant, must be iv size */

    switch( cipher_info->mode )
    {
        case MBEDTLS_MODE_GCM:
        case MBEDTLS_MODE_CCM:
            t_out->fixed_ivlen = 4; /* redundant, must be 4 for AEAD */
            t_in->fixed_ivlen = 4;  /* redundant, must be 4 for AEAD */
            t_out->maclen = 0;
            t_in->maclen = 0;
            switch( tag_mode )
            {
                case 0: /* Full tag */
                    t_out->taglen = 16;
                    t_in->taglen = 16;
                    break;
                case 1: /* Partial tag */
                    t_out->taglen = 8;
                    t_in->taglen = 8;
                    break;
                default:
                    return( 1 );
            }
            break;

        case MBEDTLS_MODE_STREAM:
        case MBEDTLS_MODE_CBC:
            t_out->fixed_ivlen = 0; /* redundant, must be 0 */
            t_in->fixed_ivlen = 0;  /* redundant, must be 0 */
            t_out->taglen = 0;
            t_in->taglen = 0;
            switch( tag_mode )
            {
                case 0: /* Full tag */
                    t_out->maclen = maclen;
                    t_in->maclen = maclen;
                    break;
                case 1: /* Partial tag */
                    t_out->maclen = maclen / 2;
                    t_in->maclen = maclen / 2;
                    break;
                default:
                    return( 1 );
            }
            break;
        default:
            return( 1 );
            break;
    }

    /* Setup MAC contexts */

    if( cipher_info->mode == MBEDTLS_MODE_CBC ||
        cipher_info->mode == MBEDTLS_MODE_STREAM )
    {
        CHK( mbedtls_md_setup( &t_out->md_ctx_enc, md_info, 1 ) == 0 );
        CHK( mbedtls_md_setup( &t_out->md_ctx_dec, md_info, 1 ) == 0 );
        CHK( mbedtls_md_setup( &t_in->md_ctx_enc,  md_info, 1 ) == 0 );
        CHK( mbedtls_md_setup( &t_in->md_ctx_dec,  md_info, 1 ) == 0 );

        if( ver > MBEDTLS_SSL_MINOR_VERSION_0 )
        {
            CHK( mbedtls_md_hmac_starts( &t_in->md_ctx_enc,
                                         md0, maclen ) == 0 );
            CHK( mbedtls_md_hmac_starts( &t_in->md_ctx_dec,
                                         md1, maclen ) == 0 );
            CHK( mbedtls_md_hmac_starts( &t_out->md_ctx_enc,
                                         md1, maclen ) == 0 );
            CHK( mbedtls_md_hmac_starts( &t_out->md_ctx_dec,
                                         md0, maclen ) == 0 );
        }
#if defined(MBEDTLS_SSL_PROTO_SSL3)
        else
        {
            memcpy( &t_in->mac_enc, md0, maclen );
            memcpy( &t_in->mac_dec, md1, maclen );
            memcpy( &t_out->mac_enc, md1, maclen );
            memcpy( &t_out->mac_dec, md0, maclen );
        }
#endif
    }
    free( md0 );
    free( md1 );

    /* Setup cipher contexts */

    CHK( mbedtls_cipher_setup( &t_in->cipher_ctx_enc,  cipher_info ) == 0 );
    CHK( mbedtls_cipher_setup( &t_in->cipher_ctx_dec,  cipher_info ) == 0 );
    CHK( mbedtls_cipher_setup( &t_out->cipher_ctx_enc, cipher_info ) == 0 );
    CHK( mbedtls_cipher_setup( &t_out->cipher_ctx_dec, cipher_info ) == 0 );

    if( cipher_info->mode == MBEDTLS_MODE_CBC )
    {
        CHK( mbedtls_cipher_set_padding_mode( &t_in->cipher_ctx_enc,
                                              MBEDTLS_PADDING_NONE ) == 0 );
        CHK( mbedtls_cipher_set_padding_mode( &t_in->cipher_ctx_dec,
                                              MBEDTLS_PADDING_NONE ) == 0 );
        CHK( mbedtls_cipher_set_padding_mode( &t_out->cipher_ctx_enc,
                                              MBEDTLS_PADDING_NONE ) == 0 );
        CHK( mbedtls_cipher_set_padding_mode( &t_out->cipher_ctx_dec,
                                              MBEDTLS_PADDING_NONE ) == 0 );
    }

    CHK( mbedtls_cipher_setkey( &t_in->cipher_ctx_enc, key0,
                                keylen << 3, MBEDTLS_ENCRYPT ) == 0 );
    CHK( mbedtls_cipher_setkey( &t_in->cipher_ctx_dec, key1,
                                keylen << 3, MBEDTLS_DECRYPT ) == 0 );
    CHK( mbedtls_cipher_setkey( &t_out->cipher_ctx_enc, key1,
                                keylen << 3, MBEDTLS_ENCRYPT ) == 0 );
    CHK( mbedtls_cipher_setkey( &t_out->cipher_ctx_dec, key0,
                                keylen << 3, MBEDTLS_DECRYPT ) == 0 );
    free( key0 );
    free( key1 );

    /* Setup IV's */

    memcpy( &t_in->iv_dec, iv_dec, sizeof( iv_dec ) );
    memcpy( &t_in->iv_enc, iv_enc, sizeof( iv_enc ) );
    memcpy( &t_out->iv_dec, iv_enc, sizeof( iv_enc ) );
    memcpy( &t_out->iv_enc, iv_dec, sizeof( iv_dec ) );

    return( 0 );
}
#endif

int transform_free( mbedtls_mps_transform_t *transform_ )
{
#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( transform_->type == 1 )
    {
        mbedtls_ssl_transform_free( &transform_->real );
    }
    else
#else
    ((void) transform_);
#endif
    {
        /* No freeing necessary for mock transform */
    }

    return( 0 );
}

int transform_encrypt( mbedtls_mps_transform_t *transform_, mps_rec *rec,
                       int (*f_rng)(void *, unsigned char *, size_t),
                       void *p_rng )
{
    size_t idx;
    size_t pre_pad;
    size_t post_pad;
    mbedtls_transform_mock_t *transform;

    /* Distinguish between our test-only mock transforms and
     * the real record transformations used in [D]TLS. */

    printf( "Transform %p\n", transform_ );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( transform_->type == 1 )
    {
        /* Real transformation */

        int ret;
        mbedtls_ssl_transform *real = &transform_->real;
        mbedtls_record rec_alt;

        /* TEMPORARY:
         * Convert between different versions of record structure.
         * This needs to be uniformized at some point.
         */

        rec_alt.buf = rec->buf.buf;
        rec_alt.buf_len = rec->buf.buf_len;
        rec_alt.data_len = rec->buf.data_len;
        rec_alt.data_offset = rec->buf.data_offset;
        rec_alt.type = rec->type;
        rec_alt.ctr[0] = ( rec->ctr >> 56 ) & 0xFF;
        rec_alt.ctr[1] = ( rec->ctr >> 48 ) & 0xFF;
        rec_alt.ctr[2] = ( rec->ctr >> 40 ) & 0xFF;
        rec_alt.ctr[3] = ( rec->ctr >> 32 ) & 0xFF;
        rec_alt.ctr[4] = ( rec->ctr >> 24 ) & 0xFF;
        rec_alt.ctr[5] = ( rec->ctr >> 16 ) & 0xFF;
        rec_alt.ctr[6] = ( rec->ctr >>  8 ) & 0xFF;
        rec_alt.ctr[7] = ( rec->ctr >>  0 ) & 0xFF;
        write_version( rec->major_ver, rec->minor_ver,
                       MPS_L2_MODE_STREAM, &rec_alt.ver[0] );

        printf( "Encrypt...\n" );
        ret = ssl_encrypt_buf( NULL, real, &rec_alt, f_rng, p_rng );
        if( ret != 0 )
            return( ret );

        rec->buf.data_offset = rec_alt.data_offset;
        rec->buf.data_len = rec_alt.data_len;

        return( 0 );
    }
#endif

    /* Mock transformation */
    ((void) p_rng);
    ((void) f_rng);

    transform = &transform_->mock;
    if( transform->enabled == 0 )
    {
        /* Identity transformation */
        return( 0 );
    }

//    srand( rand() % time( NULL ) );

    /* Add record sequence number */
    if( rec->buf.data_offset < sizeof( rec->ctr ) )
        return( -1 );

    printf( "Add sequence number %u\n", (unsigned) rec->ctr );
    rec->buf.data_offset -= sizeof( rec->ctr );
    rec->buf.data_len    += sizeof( rec->ctr );
    memcpy( rec->buf.buf + rec->buf.data_offset, &rec->ctr,
            sizeof( rec->ctr ) );

    /* Add epoch */
    if( rec->buf.data_offset < sizeof( rec->epoch ) )
        return( -1 );

    printf( "Add epoch %u\n", (unsigned) rec->epoch );
    rec->buf.data_offset -= sizeof( rec->epoch );
    rec->buf.data_len    += sizeof( rec->epoch );
    memcpy( rec->buf.buf + rec->buf.data_offset,
            (unsigned char*) &rec->epoch, sizeof( rec->epoch ) );

    /* Add pre-padding */
    pre_pad = transform->pad;
    if( rec->buf.data_offset < pre_pad )
        return( -1 );
    printf( "Add pre-padding %u\n", (unsigned) pre_pad );

    rec->buf.data_offset -= pre_pad;
    rec->buf.data_len    += pre_pad;
    for( idx=0; idx < pre_pad; idx++ )
        rec->buf.buf[ rec->buf.data_offset + idx ] = idx;

    /* Add random post-padding */
    post_pad = rand() % transform->pad;
    printf( "Add post-padding %u\n", (unsigned) post_pad );

    rec->buf.buf[ rec->buf.data_len ] = 0x1;
    memset( rec->buf.buf + rec->buf.data_len + 1, 0, post_pad );
    rec->buf.data_len += post_pad + 1;

    return( 0 );
}

int transform_decrypt( mbedtls_mps_transform_t *transform_, mps_rec *rec )
{
    size_t idx;
    size_t pre_pad;
    size_t post_pad;
    uint8_t val;
    uint64_t ctr;

    mbedtls_transform_mock_t *transform;
    transform = &transform_->mock;

    /* Distinguish between our test-only mock transforms and
     * the real record transformations used in [D]TLS. */

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( transform_->type == 1 )
    {
        /* Real transformations */

        int ret;
        mbedtls_ssl_transform *real = &transform_->real;
        mbedtls_record rec_alt;

        /* TEMPORARY:
         * Convert between different versions of record structure.
         * This needs to be uniformized at some point.
         */

        rec_alt.buf = rec->buf.buf;
        rec_alt.buf_len = rec->buf.buf_len;
        rec_alt.data_len = rec->buf.data_len;
        rec_alt.data_offset = rec->buf.data_offset;
        rec_alt.type = rec->type;
        rec_alt.ctr[0] = ( rec->ctr >> 56 ) & 0xFF;
        rec_alt.ctr[1] = ( rec->ctr >> 48 ) & 0xFF;
        rec_alt.ctr[2] = ( rec->ctr >> 40 ) & 0xFF;
        rec_alt.ctr[3] = ( rec->ctr >> 32 ) & 0xFF;
        rec_alt.ctr[4] = ( rec->ctr >> 24 ) & 0xFF;
        rec_alt.ctr[5] = ( rec->ctr >> 16 ) & 0xFF;
        rec_alt.ctr[6] = ( rec->ctr >>  8 ) & 0xFF;
        rec_alt.ctr[7] = ( rec->ctr >>  0 ) & 0xFF;
        write_version( rec->major_ver, rec->minor_ver,
                       MPS_L2_MODE_STREAM, &rec_alt.ver[0] );

        ret = ssl_decrypt_buf( NULL, real, &rec_alt );
        if( ret != 0 )
            return( ret );

        rec->buf.data_offset = rec_alt.data_offset;
        rec->buf.data_len = rec_alt.data_len;

        return( 0 );
    }
#endif

    /* Mock transformations */

    printf( "Decryption, %p\n", transform );
    if( rec->buf.data_offset != 0 )
    {
        printf( "BAD OFFSET!\n" );
        return( -1 );
    }
    if( transform->enabled == 0 )
    {
        /* Identity transformation */
        return( 0 );
    }

    printf( "Decryption, pre-padding %u\n", (unsigned) transform->pad );

    /* Check pre-padding */
    pre_pad = transform->pad;
    if( rec->buf.data_len <= pre_pad )
        return( -1 );
    for( idx = 0; idx < pre_pad; idx++ )
    {
        if( rec->buf.buf[idx] != idx )
        {
            printf( "Bad pre-padding!\n" );
            return( MPS_ERR_INVALID_MAC );
        }
    }
    rec->buf.data_offset = pre_pad;
    rec->buf.data_len -= pre_pad;

    /* Check post-padding */
    for( idx = rec->buf.data_len - 1; idx > 0; idx-- )
    {
        val = rec->buf.buf[ rec->buf.data_offset + idx ];
        if( val == 0 )
            continue;
        if( val != 1 )
        {
            printf( "Bad post-padding\n" );
            return( MPS_ERR_INVALID_MAC );
        }
        break;
    }
    val = rec->buf.buf[ rec->buf.data_offset + idx ];
    if( val != 1 )
        return( -1 );

    post_pad = rec->buf.data_len - idx - 1;
    if( post_pad >= transform->pad )
        return( -1 );
    printf( "Found post-padding %u\n", (unsigned) post_pad );
    rec->buf.data_len -= post_pad + 1;

    /* Check epoch */
    if( rec->buf.data_len < sizeof( rec->epoch ) )
        return( -1 );
    if( memcmp( rec->buf.buf + rec->buf.data_offset,
                (unsigned char*)&rec->epoch, sizeof( rec->epoch ) ) != 0 )
    {
        return( -1 );
    }
    rec->buf.data_offset += sizeof( rec->epoch );
    rec->buf.data_len    -= sizeof( rec->epoch );

    /* Check sequence number */
    if( rec->buf.data_len < sizeof( rec->ctr ) )
        return( MPS_ERR_INVALID_MAC );

    memcpy( &ctr, rec->buf.buf + rec->buf.data_offset, sizeof( rec->ctr ) );
    if( ctr != rec->ctr )
    {
        printf( "Sequence number mismatch: Expected %u, got %u\n",
                (unsigned) rec->ctr, (unsigned) ctr );
        return( MPS_ERR_INVALID_MAC );
    }
    rec->buf.data_offset += sizeof( rec->ctr );
    rec->buf.data_len    -= sizeof( rec->ctr );

    return( 0 );
}

int transform_get_expansion( mbedtls_mps_transform_t *transform,
                             size_t *pre_exp, size_t *post_exp )
{
#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( transform->type == 1 )
    {
        /* Real transformation */

        /* For the moment copied from mbedtls_ssl_get_record_expansion */
        *pre_exp = transform->real.ivlen - transform->real.fixed_ivlen;
        printf( "Pre-expansion: %u\n", (unsigned) *pre_exp );
        switch( mbedtls_cipher_get_cipher_mode(
                    &transform->real.cipher_ctx_enc ) )
        {
            case MBEDTLS_MODE_GCM:
            case MBEDTLS_MODE_CCM:
            case MBEDTLS_MODE_STREAM:
                *post_exp = transform->real.minlen;
                break;

            case MBEDTLS_MODE_CBC:
                *post_exp = transform->real.maclen
                    + mbedtls_cipher_get_block_size(
                        &transform->real.cipher_ctx_enc );
                break;

            default:
                return( -1 );
        }

        return( 0 );
    }
#endif

    /* Mock transformations */

    if( transform->mock.enabled == 0 )
    {
        /* Identity transform doesn't expand. */
        *pre_exp = 0;
        *post_exp = 0;
        return( 0 );
    }

    *pre_exp = transform->mock.pad + sizeof( ((mps_rec*) NULL)->ctr ) +
                                     sizeof( ((mps_rec*) NULL)->epoch );
    *post_exp = transform->mock.pad;
    return( 0 );
}

/*
 *
 * Helper structures for Layer 3 testing
 *
 */

/* This structure is used for Layer 3 random testing
 * and represents a message (CCS, Alert, App, HS)
 * to be sent and received through Layer 3. */
typedef struct
{
    mbedtls_mps_msg_type_t type;
    union
    {
        struct
        {
            mps_hs_type type;
            unsigned char *buf;
            size_t len;
            size_t send_progress;
            size_t read_progress;
        } hs;
        struct
        {
            unsigned char *buf;
            size_t len;
            size_t send_progress;
            size_t read_progress;
        } app;
        mps_l3_alert_in alert;
    } data;

} typed_data_chunk_l3;

/*
 *
 * Helper structures for Layer 4 testing.
 *
 */

/* Dummy retransmission callback. */

typedef struct
{
    size_t cur_chunk;
    size_t num_chunks;
    size_t bytes_per_chunk;
} dummy_cb_ctx;

size_t mps_l4_dummy_callback_msg_length( dummy_cb_ctx *ctx )
{
    return( ctx->num_chunks + ctx->bytes_per_chunk );
}

int mps_l4_dummy_callback( mbedtls_mps_write_cb_ctx_t const *ctx,
                           mbedtls_writer_ext *writer )
{
    int ret;
    dummy_cb_ctx *dummy_ctx = ( (dummy_cb_ctx*) ctx );
    unsigned char *chunk;
    size_t idx;

    printf( "Dummy callback called - state %u / %u\n",
            (unsigned) dummy_ctx->cur_chunk,
            (unsigned) dummy_ctx->num_chunks );

    ret = mbedtls_writer_get_ext( writer, dummy_ctx->bytes_per_chunk,
                                  &chunk, NULL );
    if( ret == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
        return( MBEDTLS_MPS_RETRANSMISSION_CALLBACK_PAUSE );
    else if( ret != 0 )
        return( ret );

    for( idx = 0; idx < dummy_ctx->bytes_per_chunk; idx++ )
    {
        chunk[idx] = (unsigned char)
            ( ( dummy_ctx->cur_chunk * dummy_ctx->bytes_per_chunk ) + idx );
    }

    ret = mbedtls_writer_commit_ext( writer );
    if( ret != 0 )
        return( ret );

    dummy_ctx->cur_chunk++;
    if( dummy_ctx->cur_chunk == dummy_ctx->num_chunks )
    {
        printf( "Callback done.\n" );
        dummy_ctx->cur_chunk = 0;
        return( 0 );
    }

    printf( "Callback not yet done -- need to be called again.\n" );
    return( MBEDTLS_MPS_RETRANSMISSION_CALLBACK_PAUSE );
}

/* END_HEADER */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_feed_empty( int option )
{
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    switch( option )
    {
        case 0: /* NULL buffer */
            TEST_ASSERT( mbedtls_reader_feed( &rd, NULL, sizeof( buf ) ) ==
                         MBEDTLS_ERR_READER_INVALID_ARG );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    /* Subsequent feed-calls should still succeed. */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );

    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_single_round( int with_acc )
{
    /* The most basic use case: lower layer provides a buffer,
      * upper layer fetches it in a single go. */
    unsigned char bufA[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_single_step_multiple_rounds( int with_acc )
{
    /* Test multiple rounds of the lower layer providing data
     * and the upper layer fetching it in a single go. */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_single_round( int with_acc )
{
    /* Lower layer provides data that the upper layer fully consumes
     * through multiple `get` calls. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 10, 70 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    TEST_ASSERT( memcmp( tmp, buf + 80, 20 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_no_pausing_multiple_steps_multiple_rounds( int with_acc )
{
    /* Repeat "Lower layer provides data the the upper layer fully
     * consumes through multiple `get` calls" multiple times. */
    unsigned char bufA[100], bufB[100];
    unsigned char acc[10];
    unsigned char *tmp;
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    if( with_acc == 0 )
        mbedtls_reader_init( &rd, NULL, 0 );
    else
        mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 10, 70 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB, 100 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_disabled()
{
    /* If read-request goes beyond current read buffer
     * and pausing is not used, expected OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_NEED_ACCUMULATOR );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_needed_buffer_too_small()
{
    /* If read-request goes beyond current read buffer
     * and pausing is used but the pause buffer is too small,
     * expect failure in the subsequent reclaim. */
    unsigned char buf[100];
    unsigned char acc[10];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_multiple_pausing( int option )
{
    unsigned char bufA[100], bufB[20], bufC[10];
    unsigned char *tmp;
    unsigned char acc[50];
    size_t tmp_len;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);
    for( int i=0; (unsigned) i < sizeof( bufC ); i++ )
        bufC[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    switch( option )
    {
        case 0: /* Fetch same chunks, commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * large enough. */

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, &tmp_len ) == 0 );
            TEST_ASSERT( tmp_len == 10 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufC, sizeof( bufC ) ) == 0 );;

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufB + 10, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufC, 10 ) == 0 );
            break;

        case 1: /* Fetch same chunks, commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * not large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 51, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                         MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
            break;

        case 2: /* Fetch same chunks, don't commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufC, sizeof( bufC ) ) == 0 );;

            /* Consume */
            TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 40, bufC, 10 ) == 0 );
            break;

        case 3: /* Fetch same chunks, don't commit afterwards, and
                 * then exceed bounds of new buffer; accumulator
                 * not large enough. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 21, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_OUT_OF_DATA );

            /* Prepare */
            TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                         MBEDTLS_ERR_READER_ACCUMULATOR_TOO_SMALL );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_reclaim_data_left( int option )
{
    /* Attempt to reclaim when the higher layer
     * hasn't fully consumed the buffer. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );

    /* Consumption (upper layer) */
    switch( option )
    {
        case 0:
            /* Fetch (but not commit) the entire buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ), &tmp, NULL )
                         == 0 );
            TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
            break;

        case 1:
            /* Fetch (but not commit) parts of the buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf, sizeof( buf ) / 2 ) == 0 );
            break;

        case 2:
            /* Fetch and commit parts of the buffer, then
             * fetch but not commit the rest of the buffer. */
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf, sizeof( buf ) / 2 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, sizeof( buf ) / 2,
                                             &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, buf + sizeof( buf ) / 2,
                                 sizeof( buf ) / 2 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_DATA_LEFT );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_reclaim_data_left_retry()
{
    /* Lower layer attempts to reclaim but finds that data
     * remains to be consumed and hence passes the reader
     * back to upper layer who continues processing. */
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_reader rd;

    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, NULL, 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 50, 50 ) == 0 );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) ==
                 MBEDTLS_ERR_READER_DATA_LEFT );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 50, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf + 50, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    switch( option )
    {
        case 0:  /* Single uncommited fetch at pausing */
        case 1:
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;
        default: /* Multiple uncommitted fetches at pausing */
            break;
    }
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );

    /* Consumption */
    switch( option )
    {
        case 0: /* Single fetch at pausing, re-fetch with commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 1: /* Single fetch at pausing, re-fetch without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 2: /* Multiple fetches at pausing, repeat without commit. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 3: /* Multiple fetches at pausing, repeat with commit 1. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            break;

        case 4: /* Multiple fetches at pausing, repeat with commit 2. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        case 5: /* Multiple fetches at pausing, repeat with commit 3. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
    }

    /* In all cases, fetch the rest of the second buffer. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufB + 10, 90 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_pausing_multiple_feeds( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[70];
    mbedtls_reader rd;
    size_t fetch_len;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );

    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    /* 20 left, ask for 70 -> 50 overhead */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );

    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    switch( option )
    {
        case 0: /* 10 + 10 + 80 byte feed */
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 10 ) ==
                         MBEDTLS_ERR_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 10, 10 ) ==
                         MBEDTLS_ERR_READER_NEED_MORE );
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 20, 80 ) == 0 );
            break;

        case 1: /* 50 x 1byte */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 1 ) == 0 );
            break;

        case 2: /* 49 x 1byte + 51bytes */
            for( int num_feed=0; num_feed<49; num_feed++ )
            {
                TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + num_feed, 1 ) ==
                             MBEDTLS_ERR_READER_NEED_MORE );
            }
            TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 49, 51 ) == 0 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 70, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
    TEST_ASSERT( memcmp( tmp + 20, bufB, 50 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 1000, &tmp, &fetch_len ) == 0 );
    switch( option )
    {
        case 0:
            TEST_ASSERT( fetch_len == 50 );
            break;

        case 1:
            TEST_ASSERT( fetch_len == 0 );
            break;

        case 2:
            TEST_ASSERT( fetch_len == 50 );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

    /* Wrapup */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_commit_in_old()
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Consumption (upper layer) */
    /* Ask for more than what's available. */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA, 80 ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, 5 ) ==
                 MBEDTLS_ERR_READER_NEED_MORE );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 5, 3 ) ==
                 MBEDTLS_ERR_READER_NEED_MORE );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB + 8, sizeof( bufB ) - 8 ) ==
                 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) ==
                 MBEDTLS_ERR_READER_UNEXPECTED_OPERATION );
    /* Consumption */
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 80, 10 ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, bufA + 90, 10 ) == 0 );
    TEST_ASSERT( memcmp( tmp + 10, bufB, 10 ) == 0 );
    /* Wrapup */
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_reader_inconsistent_usage( int option )
{
    unsigned char bufA[100], bufB[100];
    unsigned char *tmp;
    unsigned char acc[40];
    mbedtls_reader rd;
    int success = 0;
    for( int i=0; (unsigned) i < sizeof( bufA ); i++ )
        bufA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( bufB ); i++ )
        bufB[i] = ~ ((unsigned char) i);

    /* Preparation (lower layer) */
    mbedtls_reader_init( &rd, acc, sizeof( acc ) );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufA, sizeof( bufA ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_reader_get( &rd, 80, &tmp, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_get( &rd, 20, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Preparation */
    TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_feed( &rd, bufB, sizeof( bufB ) ) == 0 );
    /* Consumption */
    switch( option )
    {
        case 0:
            /* Ask for buffered data in a single chunk, no commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 1:
            /* Ask for buffered data in a single chunk, with commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 30, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 20 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 20, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        case 2:
            /* Ask for more than was requested when pausing, #1 */
            TEST_ASSERT( mbedtls_reader_get( &rd, 31, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 3:
            /* Ask for more than was requested when pausing #2 */
            TEST_ASSERT( mbedtls_reader_get( &rd, (unsigned) -1, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 4:
            /* Asking for buffered data in different
             * chunks than before CAN fail. */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 10, &tmp, NULL ) ==
                         MBEDTLS_ERR_READER_INCONSISTENT_REQUESTS );
            break;

        case 5:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - no commits */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 6:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - intermediate commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            success = 1;
            break;

        case 7:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - end commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        case 8:
            /* Asking for buffered data different chunks
             * than before NEED NOT fail - intermediate & end commit */
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 80, 15 ) == 0 );
            TEST_ASSERT( mbedtls_reader_get( &rd, 15, &tmp, NULL ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            TEST_ASSERT( memcmp( tmp, bufA + 95, 5 ) == 0 );
            TEST_ASSERT( memcmp( tmp + 5, bufB, 10 ) == 0 );
            TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );
            success = 1;
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }

    if( success == 1 )
    {
        /* In all succeeding cases, fetch the rest of the second buffer. */
        TEST_ASSERT( mbedtls_reader_get( &rd, 90, &tmp, NULL ) == 0 );
        TEST_ASSERT( memcmp( tmp, bufB + 10, 90 ) == 0 );
        TEST_ASSERT( mbedtls_reader_commit( &rd ) == 0 );

        /* Wrapup */
        TEST_ASSERT( mbedtls_reader_reclaim( &rd, NULL ) == 0 );
    }

    /* Wrapup */
    mbedtls_reader_free( &rd );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_random_usage( int num_out_chunks,
                                      int max_chunk_size,
                                      int max_request,
                                      int acc_size )

{
    /* Randomly pass a reader object back and forth between lower and
     * upper layer and let each of them call the respective reader API
     * functions in a random fashion.
     *
     * On the lower layer, we're tracking and concatenating
     * the data passed to successful feed calls.
     *
     * For the upper layer, we track and concatenate buffers
     * obtained from successful get calls.
     *
     * As long as the lower layer calls reclaim at least once, (resetting the
     * fetched but not-yet-committed data), this should always lead to the same
     * stream of outgoing/incoming data for the lower/upper layers, even if
     * most of the random calls fail.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */
    int ret;
    unsigned char *acc = NULL;
    unsigned char *outgoing, *incoming;
    unsigned char *cur_chunk = NULL;
    size_t cur_out_chunk, out_pos, in_commit, in_fetch;
    int rand_op;  /* Lower layer:
                   * - Reclaim (0)
                   * - Feed (1)
                   * Upper layer:
                   * - Get, do tolerate smaller output (0)
                   * - Get, don't tolerate smaller output (1)
                   * - Commit (2) */
    int mode = 0; /* Lower layer (0) or Upper layer (1) */
    int reclaimed = 1; /* Have to call reclaim at least once before
                        * returning the reader to the upper layer. */
    mbedtls_reader rd;

    if( acc_size > 0 )
    {
        acc = malloc( acc_size );
        TEST_ASSERT( acc != NULL );
    }

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
//    srand( time( NULL ) );

    outgoing = malloc( num_out_chunks * max_chunk_size );
    incoming = malloc( num_out_chunks * max_chunk_size );
    TEST_ASSERT( outgoing != NULL );
    TEST_ASSERT( incoming != NULL );

    mbedtls_reader_init( &rd, acc, acc_size );

    cur_out_chunk = 0;
    in_commit = 0;
    in_fetch = 0;
    out_pos = 0;
    while( cur_out_chunk < (unsigned) num_out_chunks )
    {
        if( mode == 0 )
        {
            /* Choose randomly between reclaim and feed */
            rand_op = rand() % 2;

            if( rand_op == 0 )
            {
                /* Reclaim */
                ret = mbedtls_reader_reclaim( &rd, NULL );

                if( ret == 0 )
                {
                    TEST_ASSERT( cur_chunk != NULL );
                    free( cur_chunk );
                    cur_chunk = NULL;
                }
                reclaimed = 1;
            }
            else
            {
                /* Feed reader with a random chunk */
                unsigned char *tmp;
                size_t tmp_size;
                if( cur_out_chunk == (unsigned) num_out_chunks )
                    continue;

                tmp_size = ( rand() % max_chunk_size ) + 1;
                tmp = malloc( tmp_size );
                TEST_ASSERT( tmp != NULL );

                TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, tmp, tmp_size ) == 0 );
                ret = mbedtls_reader_feed( &rd, tmp, tmp_size );

                if( ret == 0 || ret == MBEDTLS_ERR_READER_NEED_MORE )
                {
                    cur_out_chunk++;
                    memcpy( outgoing + out_pos, tmp, tmp_size );
                    out_pos += tmp_size;
                }

                if( ret == 0 )
                {
                    TEST_ASSERT( cur_chunk == NULL );
                    cur_chunk = tmp;
                }
                else
                {
                    free( tmp );
                }

            }

            /* Randomly switch to consumption mode if reclaim
             * was called at least once. */
            if( reclaimed == 1 && rand() % 3 == 0 )
            {
                in_fetch = 0;
                mode = 1;
            }
        }
        else
        {
            /* Choose randomly between get tolerating fewer data,
             * get not tolerating fewer data, and commit. */
            rand_op = rand() % 3;
            if( rand_op == 0 || rand_op == 1 )
            {
                size_t get_size, real_size;
                unsigned char *chunk_get;
                get_size = ( rand() % max_request ) + 1;
                if( rand_op == 0 )
                {
                    ret = mbedtls_reader_get( &rd, get_size, &chunk_get,
                                              &real_size );
                }
                else
                {
                    real_size = get_size;
                    ret = mbedtls_reader_get( &rd, get_size, &chunk_get, NULL );
                }

                /* Check if output is in accordance with what was written */
                if( ret == 0 )
                {
                    memcpy( incoming + in_commit + in_fetch,
                            chunk_get, real_size );
                    TEST_ASSERT( memcmp( incoming + in_commit + in_fetch,
                                         outgoing + in_commit + in_fetch,
                                         real_size ) == 0 );
                    in_fetch += real_size;
                }
            }
            else if( rand_op == 2 ) /* Commit */
            {
                ret = mbedtls_reader_commit( &rd );
                if( ret == 0 )
                {
                    in_commit += in_fetch;
                    in_fetch = 0;
                }
            }

            /* Randomly switch back to preparation */
            if( rand() % 3 == 0 )
            {
                reclaimed = 0;
                mode = 0;
            }
        }
    }

    /* Cleanup */
    mbedtls_reader_free( &rd );
    free( incoming );
    free( outgoing );
    free( acc );
    free( cur_chunk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_basic( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;
    size_t tmp_sz;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    mbedtls_reader_init( &rd, NULL, 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    /* Do actual fetching */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 101, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );

    /* ([C]ommit, [F]etch) = (0,0) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 50, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,50) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,60) */
    TEST_ASSERT( mbedtls_reader_commit_ext( &rd_ext ) == 0 );
    /* Now (C,F) = (60,60) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 41, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    /* Now (C,F) = (60,60) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 40,
                                         &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 15 );
    /* Now (C,F) = (60,75) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 26, &tmp, &tmp_sz ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 25, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 25, &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 0 );
    /* Now still (C,F) = (60,75) */

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_group_open_close( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;
    size_t tmp_sz;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    mbedtls_reader_init( &rd, NULL, 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    /* Do actual fetching */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 101, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );

    /* ([C]ommit, [F]etch) = (0,0) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 50, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,50) */
    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 51 ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 20 ) == 0 );
    /* Now (C,F) have a sub-group in the range from 50-70 */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 21, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,60) */
    /* Cannot close group yet */
    TEST_ASSERT( mbedtls_reader_group_close( &rd_ext ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 10, &tmp, NULL ) == 0 );
    /* Now (C,F) = (0,70) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_group_close( &rd_ext ) == 0 );
    /* Now only open group is 0-100 again */
    TEST_ASSERT( mbedtls_reader_commit_ext( &rd_ext ) == 0 );
    /* Now (C,F) = (70,70) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) == 0 );
    /* Now (C,F) = (70,71) */
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 30, &tmp, NULL ) ==
                 MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
    TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 29, &tmp, &tmp_sz ) == 0 );
    TEST_ASSERT( tmp_sz == 4 );
    /* Now (C,F) = (70, 75) */

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_READER */
void mbedtls_mps_reader_ext_many_groups( )
{
    /* This test checks whether the extended reader correctly
     * checks for the global bounds of the logical buffer. */

    mbedtls_reader_ext rd_ext;
    mbedtls_reader rd;
    unsigned char buf[75];
    unsigned char *tmp;

    /* Initialize reader and extended reader separately. */
    TEST_ASSERT( mbedtls_reader_init_ext( &rd_ext, 100 ) == 0 );
    mbedtls_reader_init( &rd, NULL, 0 );
    for( size_t idx=0; idx < sizeof( buf ); idx++ )
        buf[idx] = (unsigned char) idx;

    /* Prepare reader and bind it to extended reader */
    TEST_ASSERT( mbedtls_reader_feed( &rd, buf, sizeof( buf ) ) == 0 );
    TEST_ASSERT( mbedtls_reader_attach( &rd_ext, &rd ) == 0 );

    for( size_t cur_grp=1; cur_grp < MBEDTLS_READER_MAX_GROUPS; cur_grp++ )
    {
        TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 100 - 2 * cur_grp + 3,
                                             &tmp, NULL ) ==
                     MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
        TEST_ASSERT( mbedtls_reader_get_ext( &rd_ext, 1, &tmp, NULL ) == 0 );
        TEST_ASSERT( mbedtls_reader_group_open( &rd_ext,
                                                100 - 2 * ( cur_grp - 1 ) ) ==
                     MBEDTLS_ERR_READER_BOUNDS_VIOLATION );
        TEST_ASSERT( mbedtls_reader_group_open( &rd_ext,
                                                100 - 2 * cur_grp ) == 0 );
    }

    TEST_ASSERT( mbedtls_reader_group_open( &rd_ext, 1 ) ==
                 MBEDTLS_ERR_READER_TOO_MANY_GROUPS );

    TEST_ASSERT( mbedtls_reader_detach( &rd_ext ) == 0 );

exit:

    mbedtls_reader_free_ext( &rd_ext );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_feed_empty( int option )
{
    unsigned char buf[100];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( buf ); i++ )
        buf[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, NULL, 0 );
    switch( option )
    {
        case 0: /* NULL buffer */
            TEST_ASSERT( mbedtls_writer_feed( &wr, NULL, 0 ) ==
                         MBEDTLS_ERR_WRITER_INVALID_ARG );
            break;

        default:
            TEST_ASSERT( 0 );
            break;
    }
    /* Subsequent feed-calls should still succeed. */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    TEST_ASSERT( memcmp( tmp, buf, 100 ) == 0 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_single_step_single_round( int with_queue )
{
    /* The most basic use case: lower layer provides space
     * for outgoing data to be written to, and upper layer
     * fetches and writes it in a single go. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;

    for( int i=0; (unsigned) i < 100; i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    /* Can't reclaim as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Feed some buffer to the writer */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Can't feed again as we're now in producing mode */
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Producing (upper layer) */
    /* Fetch and write to the entire output buffer */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );

    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( buf, out, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_unexpected_operations()
{
    /* Unexpected operations shouldn't corrupt any internal structures.
     * This test checks this by exercising a simple writer test with
     * queueing and inserting multiple unexpected calls in between. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_mps_size_t olen;
    mbedtls_writer wr;

    for( int i=0; (unsigned) i < 100; i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < 100; i++ )
        outB[i] = ~ (unsigned char) i;

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    /* Can't reclaim as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Can't get or commit anything as long as nothing's provided. */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Feed some buffer to the writer */
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Can't feed again as we're now in producing mode */
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Test the committing again has no effect. */
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Test the committing again has no effect. */
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, &olen, NULL, 0 ) == 0 );
    TEST_ASSERT( olen == 100 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Providing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, &olen, NULL, 0 ) == 0 );
    TEST_ASSERT( olen == 100 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_single_step_multiple_rounds( int with_queue )
{
    /* Multiple rounds of lower layer providing space
     * for outgoing data to be written to, and upper layer
     * fetches and writes it in a single go. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    /* Consume exactly what's available */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_single_round( int with_queue )
{
    /* Lower layer provides output buffer that the upper layer
     * fetches and writes to in multiple `get` calls. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, out + 10, 70 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, out + 80, 20 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( buf, out, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_multiple_rounds( int with_queue )
{
    /* Repeat lower layer providing output buffer that the upper layer
     * fetches and writes to in multiple `get` calls. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 10, 70 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, outA + 80, 20 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( outA, bufA, 100 ) == 0 );
    TEST_ASSERT( memcmp( outB, bufB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_no_queueing_multiple_steps_multiple_rounds_partial_commit( int with_queue )
{
    /* Almost identical to multiple_steps_multiple_rounds_no_commit,
     * but only partially comitting writes in first round. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_mps_size_t tmp_len;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    if( with_queue == 0 )
        mbedtls_writer_init( &wr, NULL, 0 );
    else
        mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 10 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 70, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 10, 70 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 30, &tmp, &tmp_len ) == 0 );
    TEST_ASSERT( tmp_len == 20 );
    memcpy( tmp, outA + 80, 20 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 1 /*force*/ ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) == 0 );
    memcpy( tmp, outB, 100 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );

    TEST_ASSERT( memcmp( outA, bufA, 80  ) == 0 );
    TEST_ASSERT( memcmp( outB, bufB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_needed_disabled()
{
    /* If a write request goes beyond the provided output buffer
     * and queueing is not used, signal OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Preparation (lower layer) */
    mbedtls_writer_init( &wr, NULL, 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Consumption (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 50, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 50 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_DATA_LEFT );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( buf, out, 50 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_needed_too_small()
{
    /* If a write request goes beyond the provided output buffer
     * and queueing is used but the queue is too small, signal OUT_OF_DATA. */
    unsigned char buf[100];
    unsigned char out[100];
    unsigned char queue[10];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( out ); i++ )
        out[i] = (unsigned char) i;

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, buf, sizeof( buf ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 50, &tmp, NULL ) == 0 );
    memcpy( tmp, out, 50 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 100, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) ==
                 MBEDTLS_ERR_WRITER_DATA_LEFT );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( buf, out, 50 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_basic( int commit )
{
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    if( commit == 1 )
        TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_boundary()
{
    /* This test exercises the behavior of the writer
     * when a write-request is made after the entire
     * output buffer has been requested and committed.
     * There are two ways to handle this in the implementation:
     * 1. Reject the request, indicating that not enough data is available.
     * 2. Attempt to serve the request from the accumulator.
     * Currently, the implementation follows behavior 2,
     * and the test checks for that. */

    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];

    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, sizeof( bufA ), &tmp, NULL ) == 0 );
    memcpy( tmp, outA, sizeof( bufA ) );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* In behavior 2, the following write-request
     * will be served from the queue. */
    TEST_ASSERT( mbedtls_writer_get( &wr, sizeof( queue ), &tmp, NULL ) == 0 );
    memcpy( tmp, outB, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 1, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 1 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, sizeof( bufA ) ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, sizeof( queue ) ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_requests( int commit )
{
    /* This test exercises the behavior of the writer
     * when multiple requests are served from the queue. */

    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[40];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    if( commit )
        TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    TEST_ASSERT( mbedtls_writer_get( &wr, 10, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 80, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 20, 80 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_refeed()
{
    /* Test situation where multiple output buffers are
     * needed to hold the queued outbound data. */
    unsigned char bufA[100], bufB[100];
    unsigned char outA[100], outB[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
    {
        bufA[i] = 0;
        outA[i] = (unsigned char) i;
    }
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
    {
        bufB[i] = 0;
        outB[i] = ~ ((unsigned char) i);
    }

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    /* So far we have been writing to the queue, and the results
     * are not partially copied to the output buffer until the buffer is reclaimed. */
    TEST_ASSERT( memcmp( bufA, outA, 100 ) != 0 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    /* Now they should be there. */
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    for( int i=0; i<9; i++ )
    {
        TEST_ASSERT( mbedtls_writer_feed( &wr, bufB + i, 1 ) ==
                     MBEDTLS_ERR_WRITER_NEED_MORE );
    }
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB + 9, 91 ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_queue_multiple_rounds()
{
    /* Exercise three rounds of feed-get-commit-reclaim, with queueing. */
    unsigned char bufA[100], bufB[100], bufC[100];
    unsigned char outA[100], outB[100], outC[100];
    unsigned char queue[20];
    unsigned char *tmp;
    mbedtls_writer wr;
    for( int i=0; (unsigned) i < sizeof( outA ); i++ )
        outA[i] = (unsigned char) i;
    for( int i=0; (unsigned) i < sizeof( outB ); i++ )
        outB[i] = ~ ((unsigned char) i);
    for( int i=0; (unsigned) i < sizeof( outC ); i++ )
        outC[i] = (unsigned char)( 128 + i );

    /* Provisioning (lower layer) */
    mbedtls_writer_init( &wr, queue, sizeof( queue ) );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufA, sizeof( bufA ) ) == 0 );
    /* Producing (upper layer) */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outA, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outA + 90, 10 );
    memcpy( tmp + 10, outB, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufB, sizeof( bufB ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 80, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 10, 80 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 20, &tmp, NULL ) == 0 );
    memcpy( tmp, outB + 90, 10 );
    memcpy( tmp + 10, outC, 10 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) ==
                 MBEDTLS_ERR_WRITER_OUT_OF_DATA );
    /* Provisioning */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    TEST_ASSERT( mbedtls_writer_feed( &wr, bufC, sizeof( bufC ) ) == 0 );
    /* Producing */
    TEST_ASSERT( mbedtls_writer_get( &wr, 90, &tmp, NULL ) == 0 );
    memcpy( tmp, outC + 10, 90 );
    TEST_ASSERT( mbedtls_writer_commit( &wr ) == 0 );
    /* Wrapup (lower layer) */
    TEST_ASSERT( mbedtls_writer_reclaim( &wr, NULL, NULL, 0 ) == 0 );
    mbedtls_writer_free( &wr );
    TEST_ASSERT( memcmp( bufA, outA, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufB, outB, 100 ) == 0 );
    TEST_ASSERT( memcmp( bufC, outC, 100 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_WRITER */
void mbedtls_mps_writer_random_usage( int data_amount,
                                      int max_chunk_size,
                                      int max_request,
                                      int queue_size )

{
    /* Randomly pass a writer object back and forth between lower and
     * upper layer and let each of them call the respective writer API
     * functions in a random fashion.
     *
     * On the lower layer, we're tracking and concatenating
     * the data passed to successful reclaim calls.
     *
     * For the upper layer, we track and concatenate buffers
     * obtained from successful commit calls.
     *
     * As long as the lower layer calls reclaim at least once, (resetting the
     * fetched but not-yet-committed data), this should always lead to the same
     * stream of outgoing/incoming data for the lower/upper layers, even if
     * most of the random calls fail.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */
    int ret;
    unsigned char *queue = NULL;
    unsigned char *outgoing, *incoming;
    unsigned char *cur_chunk = NULL;
    mbedtls_mps_size_t cur_out_chunk_size, out_pos, in_commit, in_fetch;
    int rand_op;  /* Lower layer:
                   * - Reclaim (0)
                   * - Feed (1)
                   * Upper layer:
                   * - Get, do tolerate smaller output (0)
                   * - Get, don't tolerate smaller output (1)
                   * - Commit (2) */
    int mode = 0; /* Lower layer (0) or Upper layer (1) */
    int reclaimed = 1; /* Have to call reclaim at least once before
                        * returning the reader to the upper layer. */
    int force;
    mbedtls_writer wr;

    unsigned seed;

    if( queue_size > 0 )
    {
        queue = malloc( queue_size );
        TEST_ASSERT( queue != NULL );
    }

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
    seed = time( NULL ); // 1522933016;
    srand( seed );

    outgoing = malloc( data_amount );
    incoming = malloc( data_amount );

    TEST_ASSERT( outgoing != NULL );
    TEST_ASSERT( incoming != NULL );

    mbedtls_writer_init( &wr, queue, queue_size );

    cur_out_chunk_size = 0;
    in_commit = 0;
    in_fetch = 0;
    out_pos = 0;
    while( out_pos < (unsigned) data_amount )
    {
        if( mode == 0 )
        {
            /* Choose randomly between reclaim and feed */
            rand_op = rand() % 3;

            if( rand_op == 0 || rand_op == 1 )
            {
                mbedtls_mps_size_t out_committed;

                /* Reclaim */

                if( cur_out_chunk_size > out_pos - (unsigned) data_amount )
                    force = 1;
                else
                    force = ( rand_op == 0 );

                if( force == 1 )
                {
                    ret = mbedtls_writer_reclaim( &wr, &out_committed,
                                                  NULL, 1 );
                }
                else
                {
                    ret = mbedtls_writer_reclaim( &wr, NULL, NULL, 0 );
                    out_committed = cur_out_chunk_size;
                }

                TEST_ASSERT( ! ( force == 1 &&
                                 ret == MBEDTLS_ERR_WRITER_DATA_LEFT ) );

                if( ret == 0 )
                {
                    TEST_ASSERT( out_committed <= cur_out_chunk_size );
                    TEST_ASSERT( cur_chunk != NULL );
                    memcpy( outgoing + out_pos, cur_chunk, out_committed );
                    out_pos += out_committed;

                    free( cur_chunk );
                    cur_chunk = NULL;
                }
                reclaimed = 1;
            }
            else
            {
                /* Feed writer another outgoing data chunk */
                unsigned char *tmp;
                mbedtls_mps_size_t tmp_size;

                tmp_size = ( rand() % max_chunk_size ) + 1;
                tmp = malloc( tmp_size );
                TEST_ASSERT( tmp != NULL );

                ret = mbedtls_writer_feed( &wr, tmp, tmp_size );

                if( ret == MBEDTLS_ERR_WRITER_NEED_MORE )
                {
                    /* Outgoing data chunk has been entirely written
                     * from the queue. */
                    memcpy( outgoing + out_pos, tmp, tmp_size );
                    out_pos += tmp_size;
                }

                if( ret == 0 )
                {
                    cur_chunk = tmp;
                    cur_out_chunk_size = tmp_size;
                }
                else
                {
                    free( tmp );
                }
            }

            /* Randomly switch to consumption mode if reclaim
             * was called at least once. */
            if( reclaimed == 1 && rand() % 3 == 0 )
            {
                in_fetch = 0;
                mode = 1;
            }
        }
        else
        {
            /* Choose randomly between get tolerating fewer data,
             * get not tolerating fewer data, and commit. */
            rand_op = rand() % 3;
            if( rand_op == 0 || rand_op == 1 )
            {
                mbedtls_mps_size_t get_size, real_size;
                unsigned char *chunk_get;
                get_size = ( rand() % max_request ) + 1;
                if( get_size > data_amount - ( in_commit + in_fetch ) )
                    get_size = data_amount - in_commit - in_fetch;

                if( rand_op == 0 )
                {
                    ret = mbedtls_writer_get( &wr, get_size, &chunk_get,
                                              &real_size );
                }
                else
                {
                    real_size = get_size;
                    ret = mbedtls_writer_get( &wr, get_size, &chunk_get, NULL );
                }

                if( ret == 0 )
                {
                    /* Fill output buffer with random data. */
                    mbedtls_test_rnd_std_rand( NULL, incoming + in_commit + in_fetch, real_size );
                    memcpy( chunk_get, incoming + in_commit + in_fetch, real_size );
                    in_fetch += real_size;
                }
                else if( ret == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                {
                    TEST_ASSERT( (mbedtls_mps_size_t)( in_commit + in_fetch + get_size ) >
                                 (mbedtls_mps_size_t) queue_size );
                }
            }
            else if( rand_op == 2 ) /* Commit */
            {
                mbedtls_mps_size_t omit=0;

                /* Leave a change to omit more than what was
                 * fetched since the last commit. */
                omit = rand() % ( 2 * in_fetch + 1 );

                ret = mbedtls_writer_commit_partial( &wr, omit );
                if( omit > in_fetch )
                    TEST_ASSERT( ret ==  MBEDTLS_ERR_WRITER_INVALID_ARG );

                if( ret == 0 )
                {
                    in_commit += in_fetch - omit;
                    in_fetch = 0;
                }
            }

            /* Randomly switch back to preparation */
            if( rand() % 3 == 0 )
            {
                reclaimed = 0;
                mode = 0;
            }
        }
    }

    /* Compare results. */
    TEST_ASSERT( in_commit == (unsigned) data_amount );
    TEST_ASSERT( memcmp( outgoing, incoming, data_amount ) == 0 );

    /* Cleanup */
    mbedtls_writer_free( &wr );
    free( incoming );
    free( outgoing );
    free( queue );
    free( cur_chunk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_basic( int mode,
                           int send_multiple,
                           int send_multiple_do_flush,
                           int recv_multiple,
                           int recv_multiple_do_consume )
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises a client sending a chunk of
     * data to the server in one or multiple chunks (as
     * determined by `send_multiple`), and the server reading
     * it in one or multiple chunks (as determined by
     * `recv_multiple`).
     * If `send_multiple_do_flush` is set in addition to
     * `send_multiple`, the client flushes Layer 1 after
     * each chunk has been sent.
     * If `recv_multiple_do_consume` is set in addition to
     * `recv_multiple`, the server consumes each chunk
     * after it has read it.
     */

    unsigned char data[100];
    unsigned char data_in[100];
    size_t const data_len = sizeof( data );
    size_t send_chunk_size = 10; /* Size of outgoing chunks in the
                                  * multiple-send-chunk case. */
    size_t recv_chunk_size = 10; /* Size of incoming chunks in the
                                  * multiple-recv-chunk case. */
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L1_MODE_STREAM )
    {
        layer0_bufsize = (size_t) ( 2 * data_len );
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, 2 * data_len );
    mps_alloc_init( &srv_alloc, 2 * data_len );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Send data from client to server,
     *         either in a single or in multiple chunks. */
    if( ! send_multiple )
    {
        /* Send data in a single chunk. */
        TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

        /* The allocator is configured so that it should return
         * a buffer large enough to hold all data to be sent. */
        TEST_ASSERT( out_len >= data_len );

        memcpy( out_buf, data, data_len );

        /* Dispatch data in one go. */
        TEST_ASSERT( mps_l1_dispatch( &cli, data_len, NULL ) == 0 );
        TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
    }
    else
    {
        /* Send data in multiple chunks of size `send_chunk_size` each. */
        TEST_ASSERT( data_len % send_chunk_size == 0 );
        for( size_t idx=0; idx < data_len; idx += send_chunk_size )
        {
            /* Send data in a single chunk. */
            TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

            /* The allocator is configured so that it should return
             * a buffer large enough to hold all data to be sent. */
            TEST_ASSERT( out_len >= send_chunk_size );

            memcpy( out_buf, data + idx, send_chunk_size );

            TEST_ASSERT( mps_l1_dispatch( &cli, send_chunk_size, NULL ) == 0 );
            if( send_multiple_do_flush )
                TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
        }

        if( ! send_multiple_do_flush )
            TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
    }

    /* Step 2: Receive data on the server,
     *         either in a single or in multiple chunks. */
    if( ! recv_multiple )
    {
        if( ! ( mode == MPS_L1_MODE_DATAGRAM &&
                send_multiple                &&
                send_multiple_do_flush ) )
        {
            /* NOTE:
             * The success of the combination
             * - send_multiple == 1,
             * - send_multiple_do_flush == 0,
             * - recv_multiple == 0
             * is implementation-dependent:
             * A Layer 1 implementation is free to merge
             * successive write requests into a single datagram
             * or to split them across multiple such.
             *
             * If the Layer 1 implementation changes,
             * it might be that the test case for this
             * combination breaks.
             */

            /* Receive in a single chunk. */
            TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) == 0 );
            memcpy( data_in, in_buf, data_len );
            TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
        }
        else
        {
            TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                         MPS_ERR_REQUEST_OUT_OF_BOUNDS );
            goto cleanup;
        }
    }
    else
    {
        /* Receive in multiple chunks. */
        TEST_ASSERT( data_len % recv_chunk_size == 0 );
        for( size_t idx=0; idx < data_len; idx += recv_chunk_size )
        {
            if( recv_multiple_do_consume )
            {
                TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, recv_chunk_size ) == 0 );
                memcpy( data_in + idx, in_buf, recv_chunk_size );
                TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
            }
            else
            {
                TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, idx + recv_chunk_size ) == 0 );
                memcpy( data_in + idx, in_buf + idx, recv_chunk_size );
            }
        }

        if( ! recv_multiple_do_consume )
            TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }

    TEST_ASSERT( memcmp( data_in, data, data_len ) == 0 );

cleanup:

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L1_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_want_read( )
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises the behavior of the receiving
     * side of Layer 1 if the underlying stream transport
     * cannot provide enough incoming data.
     * Concretely:
     * 1. Client sends 10 bytes.
     * 2. Server requests 20 bytes, observing a WANT_READ.
     * 3. Client sends another 10 bytes.
     * 4. Server retries, this time successfully.
     */

    unsigned char data[20];
    size_t const data_len = sizeof( data );
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) data_len;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, data_len );
    mps_alloc_init( &srv_alloc, data_len );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Client sends first half of bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len == data_len );
    memcpy( out_buf, data, data_len / 2 );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len / 2, NULL ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == 0 );

    /* Step 2: Receive data on the server,
     *         either in a single or in multiple chunks. */

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                 MPS_ERR_WANT_READ );

    /* Step 3: Client sends second half of bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len == data_len );
    memcpy( out_buf, data + ( data_len / 2 ), data_len /2 );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len / 2, NULL ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == 0 );

    /* Step 4: Server retries, this time successfully. */

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) == 0 );
    TEST_ASSERT( memcmp( in_buf, data, data_len ) == 0 );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_dgram_want_read()
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    size_t const data_len = 20;
    unsigned char *in_buf;

    /* This test exercises the behavior of the receiving
     * side of Layer 1 if the underlying datagram transport
     * does not have any datagrams available. */

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, data_len );
    mps_alloc_init( &srv_alloc, data_len );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_DATAGRAM, &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_DATAGRAM, &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                 MPS_ERR_WANT_READ );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_dgram_bounds_violation()
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises the behavior of the receiving
     * side of the datagram-mode Layer 1 if the request
     * goes beyond the bounds of the current datagram.
     * Concretely:
     * 1. Client sends 10 bytes.
     * 2. Server requests 5 bytes successfully.
     * 3. Server requests 10 bytes, receiving
     *    a bounds violation.
     */

    unsigned char data[10];
    size_t const data_len = sizeof( data );
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, data_len );
    mps_alloc_init( &srv_alloc, data_len );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_DATAGRAM, &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_DATAGRAM, &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Client sends first half of bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len == data_len );
    memcpy( out_buf, data, data_len );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len, NULL ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == 0 );

    /* Step 2: Receive data on the server. */

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len / 2 ) == 0 );
    TEST_ASSERT( memcmp( in_buf, data, data_len / 2 ) == 0 );
    TEST_ASSERT( mps_l1_consume( &srv ) == 0 );

    TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                 MPS_ERR_REQUEST_OUT_OF_BOUNDS );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_want_write( int client_write_instead_reflush,
                                int server_trigger_want_read )
{
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises the behavior of the writing
     * side of Layer 1 if the underlying stream transport
     * cannot deliver all data.
     * Concretely:
     * 1. Client dispatches 20 bytes and attempts to flush.
     *    Only 10 bytes can be flushed, and the client gets
     *    WANT_WRITE.
     * 2. Client attempts another write, but the flush --
     *    which still can't make progress -- takes precedence,
     *    so WANT_WRITE is returned again.
     * 3a. Server reads 10 bytes, succeeds and consumes.
     * 3b. Server reads 20 bytes and fails with WANT_READ.
     * [ `server_trigger_want_read` decides between 3a and 3b ]
     * 4a. Client retries the flush and succeeds.
     * 4b. Client retries the write and succeeds.
     * [ `client_write_instead_reflush` decides between 4a and 4b ]
     * 5a (3a cont'd). Server reads 10 bytes successfully and consumes.
     * 5b (3b cont'd). Server re-tries 20 byte request and succeeds.
     */

    unsigned char data[20];
    size_t const data_len = sizeof( data );
    unsigned char *out_buf;
    unsigned char *in_buf;
    size_t out_len;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) data_len / 2;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, 100 );
    mps_alloc_init( &srv_alloc, 100 );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, data, data_len ) == 0 );

    /* Step 1: Client prepares, dispatches and attempts to flush 20 bytes. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );

    /* The allocator is configured so that it should return
     * a buffer large enough to hold all data to be sent. */
    TEST_ASSERT( out_len >= data_len );
    memcpy( out_buf, data, data_len );

    TEST_ASSERT( mps_l1_dispatch( &cli, data_len, NULL ) == 0 );
    TEST_ASSERT( mps_l1_flush( &cli ) == MPS_ERR_WANT_WRITE );

    /* Step 2: Client attempts another write. */
    TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == MPS_ERR_WANT_WRITE );

    /* Step 3a and 3b */
    if( ! server_trigger_want_read )
    {
        /* Step 3a: Server reads 10 bytes and consumes. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len / 2 ) == 0 );
        TEST_ASSERT( memcmp( in_buf, data, data_len / 2 ) == 0 );
        TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }
    else
    {
        /* Step 3b: Server reads 20 bytes and fails. */
        /* Nonetheless, the attempt should have fetched the
         * available 10 bytes from the underlying Layer 0,
         * allowing more data to be sent by the client. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) ==
                     MPS_ERR_WANT_READ );
    }

    /* Step 4a and 4b */
    if( ! client_write_instead_reflush )
    {
        /* Step 4a: Client retries flush */
        TEST_ASSERT( mps_l1_flush( &cli ) == 0 );
    }
    else
    {
        /* Step 4b: Client tries another write. */
        TEST_ASSERT( mps_l1_write( &cli, &out_buf, &out_len ) == 0 );
        /* Don't actually write anything. */
        TEST_ASSERT( mps_l1_dispatch( &cli, 0, NULL ) == 0 );
    }

    /* Step 5a and 5b */
    if( ! server_trigger_want_read )
    {
        /* Step 5a: Server reads next 10 bytes and consumes. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len / 2 ) == 0 );
        TEST_ASSERT( memcmp( in_buf, data + data_len / 2, data_len / 2 ) == 0 );
        TEST_ASSERT( mps_l1_consume( &srv ) == 0 );
    }
    else
    {
        /* Step 5b: Server retries to read 20 bytes and succeeds. */
        TEST_ASSERT( mps_l1_fetch( &srv, &in_buf, data_len ) == 0 );
        TEST_ASSERT( memcmp( in_buf, data, data_len ) == 0 );
    }

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_overly_large_request()
{
    mps_alloc alloc;
    mps_l1 l1;

    unsigned char *in_buf;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) 10;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocator */
    mps_alloc_init( &alloc, 90 );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &l1, MPS_L1_MODE_STREAM, &alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );

    /* Try to request more data than what fits in the allocator buffer. */
    TEST_ASSERT( mps_l1_fetch( &l1, &in_buf, 90 ) ==
                 MPS_ERR_WANT_READ );
    TEST_ASSERT( mps_l1_fetch( &l1, &in_buf, 90 + 1 ) ==
                 MPS_ERR_BUFFER_TOO_SMALL );

    TEST_ASSERT( mps_l1_free( &l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_random_communication( int allocator_buffer_sz,
                                          int layer0_buffer_sz )
{
    int ret;
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises a random of way for a client and server
     * to send and receive a fixed amount of data through Layer 1.
     *
     * - The send buffers xxx_send_buffer hold what each side wants to transmit,
     *   and xxx_send_pos indicates what has already been dispatched to layer 1.
     *
     * - The receive buffers xxx_recv_buffer store what has already been fetched
     *   from layer 1, with xxx_recv_pos indicating the current read position.
     *
     * In contrast to the stream-based test, we need to keep track
     * of datagram boundaries here: Architecturally, we cannot know
     * how many chunks of outgoing data Layer 1 will fit into a single
     * datagram on Layer 0. The only guarantees we have are that
     * - A flush leads enforces delivery to Layer 0, and hence
     *   enforces a datagram boundary.
     * - Layer 1 does not split single write-chunks across multiple
     *   datagrams.
     * Hence, if the sender sends data in a series of n chunks to Layer 1,
     * with the total amount of data in the first i chunks denoted by
     * M_i, and if the sender flushes after chunks i_1, ..., i_k, then the
     * set of architecturally allowed datagram boundaries in the total
     * data block of size M_n consists of all subsets of { M_1, ..., M_n }
     * containing { M_{i_1}, ..., M_{i_k} }. For example, in the extreme case
     * where the sender flushes after every chunk, the datagram boundaries
     * are precisely { M_1, ..., M_n }, if the sender only flushes after
     * dispatching all chunks, the datagram bounds are an arbitrary
     * subset of { M_1, ..., M_n } containing Mn.
     *
     * When writing, we record both the potential datagram bounds M_i as
     * well as the enforced onces M_{i_j}. When reading, we check that
     * - any read requests exceeding an enforced boundary M_{i_j} leads
     *   to a bounds violation, while
     * - any other read request leading to a bounds violation must
     *   have crossed a tentative boundary M_i.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */

    size_t len_total = 10000;
    unsigned char c2s_send_buffer[10000];
    unsigned char c2s_recv_buffer[10000];
    unsigned char s2c_send_buffer[10000];
    unsigned char s2c_recv_buffer[10000];
    size_t c2s_send_pos = 0, s2c_send_pos = 0;
    size_t c2s_recv_pos = 0, s2c_recv_pos = 0;

    /* This probably needs to be changed because we want
     * our tests to be deterministic. */
    srand( time( NULL ) );

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Generate the random content to be exchanged */
    TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, c2s_send_buffer,
                               sizeof( c2s_send_buffer ) ) == 0 );
    TEST_ASSERT( mbedtls_test_rnd_std_rand( NULL, s2c_send_buffer,
                               sizeof( s2c_send_buffer ) ) == 0 );

    /* Loop as long as at least client or server haven't completed
     * receiving or sending. */
    while( c2s_send_pos < len_total || c2s_recv_pos < len_total ||
           s2c_send_pos < len_total || s2c_recv_pos < len_total )
    {
        /* Point to the respective variables for client/server,
         * depending on the random choice of actor in this round. */
        mps_l1 *actor;
        unsigned char *recv_dst_buf, *send_src_buf;
        unsigned char *send_dst_buf, *recv_src_buf;
        size_t *send_pos, *recv_pos;
        /* Randomly choose between server and client */
        if( rand() & 1 )
        {
            actor = &cli;
            send_pos = &c2s_send_pos;
            recv_pos = &c2s_recv_pos;
            recv_dst_buf = c2s_recv_buffer;
            send_src_buf = c2s_send_buffer;
        }
        else
        {
            actor = &srv;
            send_pos = &s2c_send_pos;
            recv_pos = &s2c_recv_pos;
            recv_dst_buf = s2c_recv_buffer;
            send_src_buf = s2c_send_buffer;
        }

        /* Choose between sending and receiving */
        if( rand() & 1 )
        {
            /* Sending */
            size_t send_attempt;
            size_t send_dst_len;

            /* Once we have dispatched everything, only call flush.
             * And even if we have more to dispatch, call flush randomly. */
            if( len_total == *send_pos || rand() % 4 )
            {
                ret = mps_l1_flush( actor );
                TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                continue;
            }

            /* Request write-buffer from Layer 1
             * It might be that the request is not successful because
             * data is pending to be flushed first; in this case, skip
             * the step for now. */
            ret = mps_l1_write( actor, &send_dst_buf, &send_dst_len );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
            if( ret != 0 )
                continue;

            /* Pick a random, nonempty percentage of the remaining data
             * to be sent and copy it into the write-buffer */
            if( send_dst_len > len_total - *send_pos )
                send_dst_len = len_total - *send_pos;
            send_attempt = ( send_dst_len * ( ( rand() % 25 ) + 1 ) ) / 100;
            if( send_attempt == 0 )
                send_attempt = 1;
            memcpy( send_dst_buf, send_src_buf + *send_pos, send_attempt );

            /* Transfer data to Layer 1 -- note that this does not
             * necessarily immediately transfer the data to Layer 0. */
            ret = mps_l1_dispatch( actor, send_attempt, NULL );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );

            *send_pos += send_attempt;
        }
        else
        {
            /* Receiving */
            size_t recv_attempt;

            /* Skip this if we have already received everything */
            if( len_total == *recv_pos )
                continue;

            /* Pick random, nonempty share of the data still
             * remaining to be received. */
            recv_attempt = len_total - *recv_pos;
            if( recv_attempt > 10 * (unsigned) allocator_buffer_sz )
                recv_attempt = 10 * (unsigned) allocator_buffer_sz;

            recv_attempt = ( recv_attempt * ( ( rand() % 10 ) + 1 ) ) / 100;

            if( recv_attempt == 0 )
                recv_attempt = 1;

            /* Attempt to fetch the data.
             * Layer 1 never returns less than the requested amount
             * to the user; instead, if the read cannot be fulfilled
             * in its entirety, WANT_READ is returned, and one should
             * retry later. */
            ret = mps_l1_fetch( actor, &recv_src_buf, recv_attempt );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_READ ||
                         ( recv_attempt > (unsigned) allocator_buffer_sz &&
                           ret == MPS_ERR_BUFFER_TOO_SMALL ) );
            if( ret != 0 )
                continue;

            /* Randomly decide to ignore (and re-read on the next occasion)
             * the fetched contents. */
            if( rand() & 1 )
                continue;

            /* Request was successful; copy data to local buffer
             * and notify Layer 1 that it is fully consumed. */
            memcpy( recv_dst_buf + *recv_pos, recv_src_buf, recv_attempt );
            TEST_ASSERT( mps_l1_consume( actor ) == 0 );

            *recv_pos += recv_attempt;
        }
    }

    /* Ensure that both parties have observed the same communication. */
    TEST_ASSERT( memcmp( c2s_recv_buffer, s2c_send_buffer, len_total ) == 0 );
    TEST_ASSERT( memcmp( s2c_recv_buffer, c2s_send_buffer, len_total ) == 0 );

    TEST_ASSERT( mps_l1_free( &cli ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv ) == 0 );

    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L1 */
void mbedtls_mps_l1_random_communication_dgram( int max_dgram_size )
{
    int ret;
    mps_alloc cli_alloc, srv_alloc;
    mps_l1 cli, srv;

    /* This test exercises a random of way for a client and server
     * to send and receive a fixed amount of data through Layer 1.
     *
     * - The send buffers xxx_send_buffer hold what each side wants to transmit,
     *   and xxx_send_pos indicates what has already been dispatched to layer 1.
     *
     * - The receive buffers xxx_recv_buffer store what has already been fetched
     *   from layer 1, with xxx_recv_pos indicating the current read position.
     *
     * NOTE: This test uses rand() for random data, which is not optimal.
     *       Instead, it would be better to get the random data from a
     *       static buffer. This both eases reproducibility and allows
     *       simple conversion to a fuzz target.
     */

    size_t len_total = 10000;
    unsigned char c2s_send_buffer[10000];
    unsigned char c2s_recv_buffer[10000];
    unsigned char s2c_send_buffer[10000];
    unsigned char s2c_recv_buffer[10000];

    size_t c2s_send_pos = 0, s2c_send_pos = 0;
    size_t c2s_recv_pos = 0, s2c_recv_pos = 0;

    size_t out_chunks;  /* Counts the number of outgoing chunks. */
    size_t out_flushes; /* Counts the number of flushes.         */
    size_t dispatch_positions[ 100 ]; /* Indicates the offsets within
                                       * 0, .., len_total at which the
                                       * sending side has dispatched data. */
    size_t flush_positions[ 100 ];    /* Indicates the offsets within
                                       * 0, .., len_total at which the
                                       * sending side has flushed data.    */

    size_t cur_in_chunk; /* Indicates from which chunk the receiver
                          * is currently reading. */
    size_t cur_in_flush; /* Indicates the 0-based index of the first flush
                          * following the chunk from which the receiver
                          * is currently reading. */

    /* TO BE WRITTEN */

    ((void) len_total);
    ((void) c2s_send_pos);
    ((void) s2c_send_pos);
    ((void) c2s_recv_pos);
    ((void) s2c_recv_pos);
    ((void) c2s_recv_buffer);
    ((void) s2c_recv_buffer);
    ((void) c2s_send_buffer);
    ((void) s2c_send_buffer);
    ((void) out_chunks);
    ((void) out_flushes);
    ((void) dispatch_positions);
    ((void) flush_positions);
    ((void) cur_in_chunk);
    ((void) cur_in_flush);

    ((void) srv);
    ((void) cli);
    ((void) srv_alloc);
    ((void) cli_alloc);
    ((void) ret);
    ((void) max_dgram_size);

    TEST_ASSERT( 1 );

}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_basic( int mode,
                           int allocator_buffer_sz,
                           int layer0_buffer_sz,
                           int rec_sz,
                           int real_transforms )
{
    /* This test exercises a client making two write-requests for different
     * record content types to the server. It uses a single epoch, and the
     * write requests are small enough so that they can be served by single
     * records.
     *
     * Neither queueing nor pausing are needed, and hence
     * the test is valid both for TLS and DTLS. */

    size_t pre_exp, post_exp;

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    uint8_t const ty_B = 1;
    mbedtls_mps_epoch_id epoch_init = 0;

    uint8_t *buf;
    size_t sz;

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli;
    mps_l2_in in_srv;

    size_t const rec_hdr_max = 13; /* 5 for TLS, 13 for DTLS */

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_bufsize = (size_t) layer0_buffer_sz;
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, MPS_L2_MODE_STREAM,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, MPS_L2_MODE_STREAM,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &cli, dummy_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, dummy_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init, MPS_EPOCH_READ ) == 0 );

    /* Ensure that the test parameters are valid */
    TEST_ASSERT( transform_get_expansion( dummy_c, &pre_exp, &post_exp ) == 0 );
    TEST_ASSERT( (unsigned) allocator_buffer_sz > rec_hdr_max + ( 2 * rec_sz ) + pre_exp + post_exp );
    TEST_ASSERT( transform_get_expansion( dummy_s, &pre_exp, &post_exp ) == 0 );
    TEST_ASSERT( (unsigned) allocator_buffer_sz > rec_hdr_max + ( 2 * rec_sz ) + pre_exp + post_exp );

    /*
     * Client: Write something of type A to server
     */

    /* Step 1: Make record write request */
    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    /* Step 2: Request writer for record content */
    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );

    /* Step 3: Write and commit contents through writer. */
    TEST_ASSERT( sz == (unsigned) rec_sz );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    /* Step 4: Finish record writing. */
    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Client: Write something of type B to server
     *
     * This in particular exercises Layer 2 automatically
     * closing the record for type A.
     */

    out_cli.type = ty_B;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 2 * rec_sz, &buf, &sz ) == 0 );
    TEST_ASSERT( sz == (unsigned) ( 2 * rec_sz ) );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = ( sz - idx );
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Server: Read first record.
     */

    /* Step 1: Check for incoming data. */
    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );

    /* Step 2: Check for type and epoch. */
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type == ty_A );

    /* Step 3: Request record contents from writer. */
    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );

    /* Step 4: Process and commti record contents. */
    TEST_ASSERT( sz == (unsigned) rec_sz );
    for( uint8_t idx = 0; idx < sz; idx++ )
        TEST_ASSERT( buf[idx] == idx );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );

    /* Step 5: Close record. */
    TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

    /*
     * Server: Read second record.
     */
    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type == ty_B );
    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, 2 * rec_sz, &buf, &sz ) == 0 );
    TEST_ASSERT( sz == (unsigned) ( 2 * rec_sz ) );
    for( uint8_t idx = 0; idx < sz; idx++ )
        TEST_ASSERT( buf[idx] == ( sz - idx ) );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
    TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_non_packable_type( int mode,
                           int allocator_buffer_sz,
                           int layer0_buffer_sz  )
{
    /* This test checks that if a type is configured as non-mergable, then
     * - Layer 2 dispatches a record of that type immediately when
     *   mps_l2_write_dispatch() is called, and
     * - Layer 2 returns an error when a mps_l2_read_consume()
     *   is called with more data being available in the current
     *   incoming record.
     *
     * The alert record content type is non-mergable as of (D)TLS 1.3.
     *
     * The test makes sense for both TLS and DTLS.
     */

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    mbedtls_mps_epoch_id epoch_init = 0;

    uint8_t *buf;
    size_t sz;

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli, out_srv;
    mps_l2_in in_srv, in_cli;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_bufsize = (size_t) layer0_buffer_sz;
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, mode,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, mode,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_DISABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &cli, dummy_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init,
                                     MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, dummy_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init,
                                     MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );

    /*
     * Client: Write two consecutive messages of type ty_A to server.
     *         Expect them go get packed.
     */

    out_cli.type  = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 5, &buf, 0 ) == 0 );
    memset( buf, 42, 5 );
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );

    out_cli.type  = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 5, &buf, 0 ) == 0 );
    memset( buf, 42, 5 );
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );

    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Server: Read record.
     */

    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type  == ty_A );

    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, 5, &buf, NULL ) == 0 );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );

    /* Attempting to close should fail immediately, because more
     * data of type ty_A is available that wasn't requested. */
    TEST_ASSERT( mps_l2_read_done( &srv ) ==
                 MPS_ERR_INVALID_CONTENT_MERGE );

    /*
     * Server: Do the same as client, i.e. send two consecutive
     *         messages of type ty_A.
     *         Expect them to be delivered in two separate records.
     */

    out_srv.type  = ty_A;
    out_srv.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &srv, &out_srv ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( out_srv.wr, 5, &buf, 0 ) == 0 );
    memset( buf, 42, 5 );
    TEST_ASSERT( mbedtls_writer_commit( out_srv.wr ) == 0 );
    TEST_ASSERT( mps_l2_write_done( &srv ) == 0 );

    out_srv.type  = ty_A;
    out_srv.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &srv, &out_srv ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( out_srv.wr, 5, &buf, 0 ) == 0 );
    memset( buf, 42, 5 );
    TEST_ASSERT( mbedtls_writer_commit( out_srv.wr ) == 0 );
    TEST_ASSERT( mps_l2_write_done( &srv ) == 0 );

    TEST_ASSERT( mps_l2_write_flush( &srv ) == 0 );

    /*
     * Client: Read first record.
     */

    TEST_ASSERT( mps_l2_read_start( &cli, &in_cli ) == 0 );
    TEST_ASSERT( in_cli.epoch == epoch_init );
    TEST_ASSERT( in_cli.type  == ty_A );

    TEST_ASSERT( mbedtls_reader_get( in_cli.rd, 10, &buf, &sz ) == 0 );
    /* We should see only 5 bytes */
    TEST_ASSERT( sz == 5 );
    TEST_ASSERT( mbedtls_reader_commit( in_cli.rd ) == 0 );
    TEST_ASSERT( mps_l2_read_done( &cli ) == 0 );

    /*
     * Client: Read second record.
     */

    TEST_ASSERT( mps_l2_read_start( &cli, &in_cli ) == 0 );
    TEST_ASSERT( in_cli.epoch == epoch_init );
    TEST_ASSERT( in_cli.type  == ty_A );

    TEST_ASSERT( mbedtls_reader_get( in_cli.rd, 10, &buf, &sz ) == 0 );
    /* We should see only 5 bytes */
    TEST_ASSERT( sz == 5 );
    TEST_ASSERT( mbedtls_reader_commit( in_cli.rd ) == 0 );
    TEST_ASSERT( mps_l2_read_done( &cli ) == 0 );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_bad_record( int mode,
                                int allocator_buffer_sz,
                                int layer0_buffer_sz,
                                int failure_type )
{
    /* This test exercises the behavior of Layer 2 when
     * facing an invalid record.
     *
     * A record can be invalid for multiple reasons
     * distinguished by the `failure_type` parameter:
     * 1. The record content type is valid as per
     *    the Layer 2 configuration.
     * 2. The minor and major record versions don't
     *    match those set in the Layer 2 configuration.
     * 3. The record length is too large.
     * 4. The record has a bad MAC.
     *
     * In TLS, all these cases lead to failure,
     * while for DTLS, they lead to silent dismissal
     * of the datagram containing the record.
     */

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    mbedtls_mps_epoch_id epoch_init = 0;

    unsigned char *l1_out_buf; /* Buffer obtained from Layer 1 to which
                                * we write the malformed record.              */
    size_t l1_out_buf_len;     /* Lenght of l1_out_buf.                       */

    uint8_t *buf; /* Buffer obtained from reader/writer handed out by Layer 2 */
    size_t sz;    /* Size of buf. */

    size_t const rec_sz = 10; /* Plaintext size of the valid records
                               * sent by the client. */

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli;
    mps_l2_in in_srv;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_bufsize = (size_t) layer0_buffer_sz;
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, mode,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, mode,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A, 0, 1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A, 0, 1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &cli, dummy_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, dummy_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write a malformed record to server
     */

    TEST_ASSERT( mps_l1_write( &cli_l1, &l1_out_buf, &l1_out_buf_len ) == 0 );
    TEST_ASSERT( l1_out_buf_len >= 100 );

    /* Go through the various kinds of failure types. */

    if( mode == MPS_L2_MODE_STREAM )
    {
        size_t const tls_rec_hdr_len = 5;

        const size_t tls_rec_type_offset = 0;
        const size_t tls_rec_ver_offset  = 1;
        const size_t tls_rec_len_offset  = 3;

        uint8_t type;
        uint8_t min_ver;
        uint8_t maj_ver;
        uint16_t len;

        /* Write record content type. */
        if( failure_type != 0 )
            type = ty_A;
        else
            type = ty_A + 1;
        l1_out_buf[ tls_rec_type_offset ] = type;

        /* Write record version */
        if( failure_type != 1 )
            min_ver = MBEDTLS_SSL_MINOR_VERSION_3;
        else
            min_ver = MBEDTLS_SSL_MINOR_VERSION_1;
        if( failure_type != 2 )
            maj_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
        else
            maj_ver = 42;

        l1_out_buf[ tls_rec_ver_offset + 0 ] = maj_ver;
        l1_out_buf[ tls_rec_ver_offset + 1 ] = min_ver;

        len = rec_sz;
        l1_out_buf[ tls_rec_len_offset + 0 ] = ( len >> 8 ) & 0xFF;
        l1_out_buf[ tls_rec_len_offset + 1 ] = ( len >> 0 ) & 0xFF;

        /* Write some contents, disobeying the padding
         * structure of the dummmy transform, and hence
         * leading to the record being rejected on 'decryption'. */
        memset( l1_out_buf + tls_rec_hdr_len, 42, rec_sz );

        TEST_ASSERT( mps_l1_dispatch( &cli_l1,
                           tls_rec_hdr_len + rec_sz, NULL ) == 0 );
    }
    else
    {
        size_t const dtls_rec_hdr_len      = 13;

        size_t const dtls_rec_type_offset  = 0;
        size_t const dtls_rec_ver_offset   = 1;
        size_t const dtls_rec_epoch_offset = 3;
        size_t const dtls_rec_seq_offset   = 5;
        size_t const dtls_rec_len_offset   = 11;

        uint8_t type;
        uint8_t min_ver;
        uint8_t maj_ver;
        uint16_t len;
        uint16_t epoch;

        /* Write record content type. */
        if( failure_type != 0 )
            type = ty_A;
        else
            type = ty_A + 1;
        l1_out_buf[ dtls_rec_type_offset ] = type;

        /* Write record version */
        if( failure_type != 1 )
            min_ver = MBEDTLS_SSL_MINOR_VERSION_3;
        else
            min_ver = MBEDTLS_SSL_MINOR_VERSION_1;
        if( failure_type != 2 )
            maj_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
        else
            maj_ver = 42;

        l1_out_buf[ dtls_rec_ver_offset + 0 ] = maj_ver;
        l1_out_buf[ dtls_rec_ver_offset + 1 ] = min_ver;

        /* Write epoch */
        if( failure_type != 5 )
            epoch = epoch_init;
        else
            epoch = epoch_init + 1;

        l1_out_buf[ dtls_rec_epoch_offset + 0 ] = ( epoch >> 8 ) & 0xFF;
        l1_out_buf[ dtls_rec_epoch_offset + 1 ] = ( epoch >> 0 ) & 0xFF;

        /* Write sequence number */
        memset( l1_out_buf + dtls_rec_seq_offset, 0, 6 );

        /* Write record length */
        if( failure_type != 3 )
            len = rec_sz;
        else
            len = 10000;

        l1_out_buf[ dtls_rec_len_offset + 0 ] = ( len >> 8 ) & 0xFF;
        l1_out_buf[ dtls_rec_len_offset + 1 ] = ( len >> 0 ) & 0xFF;

        /* Write some contents, disobeying the padding
         * structure of the dummmy transform, and hence
         * leading to the record being rejected on 'decryption'. */
        memset( l1_out_buf + dtls_rec_hdr_len, 42, rec_sz );

        TEST_ASSERT( mps_l1_dispatch( &cli_l1,
                            dtls_rec_hdr_len + rec_sz, NULL ) == 0 );
    }

    /* Send a valid record; for DTLS, it will be in the same datagram
     * as the invalid one. */

    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 10, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == (unsigned) rec_sz );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );

    /* Flush to make sure a new datagram is started. */
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /* Send another valid record. For DTLS, this should be seen
     * by the server. */

    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 10, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == (unsigned) rec_sz );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = ((uint8_t) ( sz - idx ) );
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );

    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Server: Attempt to read record.
     */

    if( mode == MPS_L2_MODE_STREAM )
    {
        TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) ==
                     ( failure_type != 3 ? MPS_ERR_INVALID_RECORD
                                         : MPS_ERR_INVALID_MAC ) );
    }
    else
    {
        TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) ==
                     MPS_ERR_WANT_READ );

        TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
        TEST_ASSERT( in_srv.type == ty_A );

        TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );
        TEST_ASSERT( sz == (unsigned) rec_sz );
        for( uint8_t idx = 0; idx < sz; idx++ )
            TEST_ASSERT( buf[idx] == ((uint8_t) ( sz - idx ) ) );
        TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
        TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

        TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) ==
                     MPS_ERR_WANT_READ );
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_anti_replay( int allocator_buffer_sz,
                                 int variant )
{
    /* This test exercises the anti-replay protection of Layer 2 for DTLS.
     * Variants:
     * (a) Client sends two identital records in succession.
     *     In this case, the second record should be dropped.
     * (b) Client sends
     *     - Record A with counter c_A,
     *     - Record B with counter c_B > c_A but c_B < c_A + 64
     *     - Record A with counter c_A
     *     In this case, the second instance of A should be dropped.
     * (c) Client sends
     *     - Record A with counter c_A,
     *     - Record B with counter c_B > c_A but c_B >= c_A + 64
     *     - Record A with counter c_A
     *     In this case, the second instance of A should be dropped.
     * (d) Client sends
     *     - Record A with counter c_A
     *     - Out of order record B with counter c_B >= c_A - 64
     *     In this case, record B should be seen by the server.
     * (e) Client sends
     *     - Record A with counter c_A
     *     - Out of order record B with counter c_B < c_A - 64
     *     In this case, record B should not be seen by the server
     *     because it is too old.
     */

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    mbedtls_mps_epoch_id epoch_init = 0;

    uint64_t in_ctr;

    /* Layer 2 objects */
    mps_l2 cli, srv;

    size_t const rec_sz = 10;
    size_t sz;
    unsigned char *buf;

    mps_l2_out out_cli;
    mps_l2_in   in_srv;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L2_MODE_DATAGRAM, &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L2_MODE_DATAGRAM, &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, MPS_L1_MODE_DATAGRAM,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, MPS_L1_MODE_DATAGRAM,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A, 0, 1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A, 0, 1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &cli, dummy_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, dummy_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init, MPS_EPOCH_READ ) == 0 );

    /* Writing */

    switch( variant )
    {
        case 0:
        {
            TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 42 ) == 0 );
            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

            TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 42 ) == 0 );
            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );
            break;
        }
        case 1:
        case 2:
        {
            TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 42 ) == 0 );
            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

            if( variant == 1 )
                TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 80 ) == 0 );
            if( variant == 2 )
                TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 1223 ) == 0 );

            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx + 1;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

            TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 42 ) == 0 );
            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );
            break;
        }

        case 3:
        case 4:
        {
            TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 80 ) == 0 );
            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

            if( variant == 3 )
                TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 42 ) == 0 );
            if( variant == 4 )
                TEST_ASSERT( mps_l2_force_next_sequence_number( &cli, epoch_init, 10 ) == 0 );

            out_cli.type  = ty_A;
            out_cli.epoch = epoch_init;
            TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
            TEST_ASSERT( mbedtls_writer_get( out_cli.wr, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                buf[idx] = idx + 1;
            TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
            TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
            TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );
            break;
            break;
        }

        default:
            TEST_ASSERT( 0 );
            break;
    }

    /* Reading */

    switch( variant )
    {
        case 0:
        {
            TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
            TEST_ASSERT( in_srv.epoch == epoch_init );
            TEST_ASSERT( in_srv.type == ty_A );
            TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                TEST_ASSERT( buf[idx] == idx );
            TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

            TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
            TEST_ASSERT( in_ctr == 42 );

            TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == MPS_ERR_WANT_READ );

            /* The sequence number of a replayed record shouldn't be recorded. */
            TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
            TEST_ASSERT( in_ctr == 42 );
            break;
        }
        case 1:
        case 2:
        {
            TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
            TEST_ASSERT( in_srv.epoch == epoch_init );
            TEST_ASSERT( in_srv.type == ty_A );
            TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                TEST_ASSERT( buf[idx] == idx );
            TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

            TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
            TEST_ASSERT( in_ctr == 42 );

            TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
            TEST_ASSERT( in_srv.epoch == epoch_init );
            TEST_ASSERT( in_srv.type == ty_A );
            TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                TEST_ASSERT( buf[idx] == idx + 1 );
            TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

            TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
            if( variant == 1 )
                TEST_ASSERT( in_ctr == 80 );
            else
                TEST_ASSERT( in_ctr == 1223 );

            TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == MPS_ERR_WANT_READ );

            break;
        }

        case 3:
        case 4:
        {
            TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
            TEST_ASSERT( in_srv.epoch == epoch_init );
            TEST_ASSERT( in_srv.type == ty_A );
            TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );
            TEST_ASSERT( sz == (unsigned) rec_sz );
            for( uint8_t idx = 0; idx < sz; idx++ )
                TEST_ASSERT( buf[idx] == idx );
            TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

            TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
            TEST_ASSERT( in_ctr == 80 );

            if( variant == 3 )
            {
                TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
                TEST_ASSERT( in_srv.epoch == epoch_init );
                TEST_ASSERT( in_srv.type == ty_A );
                TEST_ASSERT( mbedtls_reader_get( in_srv.rd, rec_sz, &buf, &sz ) == 0 );
                TEST_ASSERT( sz == (unsigned) rec_sz );
                for( uint8_t idx = 0; idx < sz; idx++ )
                    TEST_ASSERT( buf[idx] == idx + 1 );
                TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
                TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

                TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
                TEST_ASSERT( in_ctr == 42 );
            }
            else
            {
                TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == MPS_ERR_WANT_READ );

                TEST_ASSERT( mps_l2_get_last_sequence_number( &srv, epoch_init, &in_ctr ) == 0 );
                TEST_ASSERT( in_ctr == 80 );
            }
            break;
        }

        default:
            TEST_ASSERT( 0 );
            break;
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_pausing( int allocator_buffer_sz,
                             int layer0_buffer_sz,
                             int accumulator_too_small,
                             int pausable_for_receiver )
{
    /* This test exercises the client making three write-requests of
     * type A, B, A, respectively, which can be served through single
     * records each. The server, however, attempts to read the contents
     * of the two type-A records in a single go, and the reader's pausing
     * functionality needs to be used to make that possible. */
    int ret;

    mps_alloc cli_alloc, srv_alloc;

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    uint8_t const ty_B = 1;
    mbedtls_mps_epoch_id epoch_init = 0;

    uint8_t *buf;
    size_t sz;
    size_t pre_exp, post_exp;

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli;
    mps_l2_in in_srv;

    /* The length of the two type A chunks the client sends.   */
    size_t const msg_chunk_size_A = 40;
    /* The length of the single type B chunk the client sends. */
    size_t const msg_chunk_size_B = 40;

    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );
    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Ensure that the test parameters are valid */
    TEST_ASSERT( transform_get_expansion( dummy_c, &pre_exp, &post_exp ) == 0 );
    TEST_ASSERT( (unsigned) allocator_buffer_sz > 40 + pre_exp + post_exp );
    TEST_ASSERT( transform_get_expansion( dummy_s, &pre_exp, &post_exp ) == 0 );
    TEST_ASSERT( (unsigned) allocator_buffer_sz > 40 + pre_exp + post_exp );

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, MPS_L2_MODE_STREAM,
       0 /* The client doesn't send anything -> no accumulator needed */,
       0 /* The client doesn't need a queue */,
       mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, MPS_L2_MODE_STREAM,
            msg_chunk_size_A - ( accumulator_too_small == 1 ),
            0 /* Server doesn't send anything -> no queue needed. */,
            mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A,
                                         MPS_L2_SPLIT_ENABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A,
                                         pausable_for_receiver == 1 ?
                                         MPS_L2_SPLIT_ENABLED :
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );

    TEST_ASSERT( mps_l2_epoch_add( &cli, dummy_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, dummy_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write something of type A to server
     *
     * The basic steps are as in the basic test mps_l2_basic above.
     */

    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, msg_chunk_size_A, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == msg_chunk_size_A );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Client: Write something of type B to server
     */

    out_cli.type = ty_B;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );
    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, msg_chunk_size_B,
                                     &buf, &sz ) == 0 );
    TEST_ASSERT( sz == msg_chunk_size_B );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    ret = mps_l2_write_done( &cli );
    TEST_ASSERT( ret == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Client: Write more of type A to the server.
     */

    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, msg_chunk_size_A,
                                     &buf, &sz ) == 0 );

    TEST_ASSERT( sz == msg_chunk_size_A );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = ( sz - idx );
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Server: Attempt to read across type-A record boundaries.
     */

    /* Open first type-A record. */
    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type == ty_A );
    /* Read first half of first type-A record. */
    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, msg_chunk_size_A / 2,
                                     &buf, &sz ) == 0 );
    TEST_ASSERT( sz == msg_chunk_size_A / 2 );
    for( uint8_t idx = 0; idx < sz; idx++ )
        TEST_ASSERT( buf[idx] == idx );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
    /* Attempt to read more, exceeding the record bounds. */
    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, msg_chunk_size_A,
                                     &buf, NULL ) ==
                 MBEDTLS_ERR_READER_OUT_OF_DATA );
    /* Pause reading. */

    TEST_ASSERT( mps_l2_read_done( &srv ) ==
                 ( pausable_for_receiver == 0 ?
                   MPS_ERR_TYPE_CANT_BE_PAUSED :
                   ( accumulator_too_small == 1 ?
                     MPS_ERR_PAUSE_REFUSED : 0 ) ) );
    if( accumulator_too_small == 1 ||
        pausable_for_receiver == 1 )
        goto exit;

    /* Open next record; turns out to be type-B. */
    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type == ty_B );
    /* Read and process its entire contents. */
    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, msg_chunk_size_B,
                                     &buf, &sz ) == 0 );
    TEST_ASSERT( sz == msg_chunk_size_B );
    for( uint8_t idx = 0; idx < sz; idx++ )
        TEST_ASSERT( buf[idx] == idx );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
    TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

    /* Open the type-A stream again and retry the request
     * that failed last time. */
    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type == ty_A );

    /* ... now it should work thanks to the reader's pausing ability. */
    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, msg_chunk_size_A,
                                     &buf, &sz ) == 0 );

    TEST_ASSERT( sz == msg_chunk_size_A );
    for( uint8_t idx = 0; idx < msg_chunk_size_A / 2; idx++ )
        /* Should get last chunk of bytes of first type-A record ... */
        TEST_ASSERT( buf[idx] == ( ( msg_chunk_size_A / 2 ) + idx ) );
    for( uint8_t idx = 0; idx < msg_chunk_size_A / 2; idx++ )
    {
        /* ... and first chunk of bytes of second type-A record. */
        TEST_ASSERT( buf[msg_chunk_size_A / 2 + idx] ==
                     ( msg_chunk_size_A - idx ) );
    }
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
    TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

exit:

    /*
     * Wrapup
     */
    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }
}
/* END_CASE */


/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_switch_epoch( int mode,
                                  int allocator_buffer_sz,
                                  int layer0_buffer_sz,
                                  int real_transforms )
{
    /* This test exercises the client sending two records of different
     * content types and epochs to the server.
     *
     * Neither queueing nor pausing are needed, and hence
     * the test is valid both for TLS and DTLS. */

    int ret;

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    uint8_t const ty_B = 1;
    mbedtls_mps_epoch_id epoch_init = 0;
    mbedtls_mps_epoch_id epoch_crypt = 1;

    uint8_t *buf;
    size_t sz;

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli;
    mps_l2_in in_srv;

    mbedtls_mps_transform_t *epoch0_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *epoch1_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *epoch0_s = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *epoch1_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        srand( 0 );
        epoch0_c->type = 1;
        epoch0_s->type = 1;
        epoch1_c->type = 1;
        epoch1_s->type = 1;
        build_transforms( &epoch0_c->real,
                          &epoch0_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA256,
                          0, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
        build_transforms( &epoch1_c->real,
                          &epoch1_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA256,
                          0, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        epoch0_c->type = 0;
        epoch0_c->mock.enabled = 0;
        epoch0_c->mock.pad = 0;
        epoch1_c->type = 0;
        epoch1_c->mock.enabled = 1;
        epoch1_c->mock.pad = 5;
        epoch0_s->type = 0;
        epoch0_s->mock.enabled = 0;
        epoch0_s->mock.pad = 0;
        epoch1_s->type = 0;
        epoch1_s->mock.enabled = 1;
        epoch1_s->mock.pad = 5;
    }

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_bufsize = (size_t) layer0_buffer_sz;
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, mode,
                              0, 0, /* no queue or accumulator */
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, mode,
                              0, 0, /* no queue or accumulator */
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );

    TEST_ASSERT( mps_l2_epoch_add( &cli,  epoch0_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv,  epoch0_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init, MPS_EPOCH_READ  ) == 0 );

    TEST_ASSERT( mps_l2_epoch_add( &cli, epoch1_c, &epoch_crypt ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, epoch1_s, &epoch_crypt ) == 0 );

    /*
     * Client: Write something of type A to server, using initial epoch
     */

    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    ret = mps_l2_write_start( &cli, &out_cli );
    if( ret != 0 )
        printf( "l2_write_start returned %d\n", ret );
    TEST_ASSERT( ret == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 20, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == 20 );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Client: Switch epochs
     */
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_crypt, MPS_EPOCH_WRITE ) == 0);

    /*
     * Client: Write something of type B to server, using new epoch
     */

    out_cli.type = ty_B;
    out_cli.epoch = epoch_crypt;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 20, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == 20 );
    for( uint8_t idx = 0; idx < sz; idx++ )
        buf[idx] = idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( ( ret = mps_l2_write_done( &cli ) ) == 0 );
    do {
        ret = mps_l2_write_flush( &cli );
        TEST_ASSERT( ret == MPS_ERR_WANT_WRITE || ret == 0 );
    } while( ret != 0 );

    /*
     * Server: Read type-A record with initial epoch.
     */

    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_init );
    TEST_ASSERT( in_srv.type == ty_A );

    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, 20, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == 20 );
    for( uint8_t idx = 0; idx < sz; idx++ )
        TEST_ASSERT( buf[idx] == idx );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );

    TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

    /*
     * Server: Switch epochs
     */
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_crypt, MPS_EPOCH_READ ) == 0 );

    /*
     * Server: Read type B record using new epoch.
     */
    TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
    TEST_ASSERT( in_srv.epoch == epoch_crypt );
    TEST_ASSERT( in_srv.type == ty_B );

    TEST_ASSERT( mbedtls_reader_get( in_srv.rd, 20, &buf, &sz ) == 0 );

    TEST_ASSERT( sz == 20 );
    for( uint8_t idx = 0; idx < sz; idx++ )
        TEST_ASSERT( buf[idx] == idx );
    TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );

    TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );

exit:

    /*
     * Wrapup
     */
    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */


/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_queueing( int allocator_buffer_sz,
                              int layer0_buffer_sz,
                              int msg_size,
                              int pausable_for_sender )
{
    /* This test exercises the client making a write-request exceeding
     * the internal maximum record size, and having Layer 2 and the
     * writer doing the necessary fragmentation under the hood. */

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t const ty_A = 0;
    mbedtls_mps_epoch_id epoch_init = 1;

    uint8_t *buf;
    size_t sz;
    size_t server_read_pos = 0;

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli;
    mps_l2_in in_srv;
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;
    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, MPS_L2_MODE_STREAM,
          0 /* The client doesn't read anything -> no accumulator needed */,
          (size_t) msg_size /* Queue as big as the intended message size */,
          mbedtls_test_rnd_std_rand,
          NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, MPS_L2_MODE_STREAM,
             0 /* The server accepts any chunksize fo incoming data   */,
             0 /* The server doesn't send anything -> no queue needed */,
             mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A, pausable_for_sender == 1,
                                         1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A, 0, 1, 0 ) == 0 );

    TEST_ASSERT( mps_l2_epoch_add( &cli, dummy_c, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, epoch_init, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, dummy_s, &epoch_init ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, epoch_init, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Request a large write of type A to server, so
     *         that the writer will need to use its queue.
     */

    out_cli.type = ty_A;
    out_cli.epoch = epoch_init;
    TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

    if( pausable_for_sender == 0 )
    {
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, (size_t) msg_size,
                                         &buf, NULL ) ==
                     MBEDTLS_ERR_WRITER_OUT_OF_DATA );
        goto exit;
    }

    TEST_ASSERT( mbedtls_writer_get( out_cli.wr, (size_t) msg_size,
                                     &buf, NULL ) == 0 );
    for( unsigned idx = 0; idx < (size_t) msg_size; idx++ )
        buf[idx] = (uint8_t) idx;
    TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

    TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli ) == 0 );

    /*
     * Server: Read type-A data.
     *
     * The large client write will have been split into multiple records,
     * so several iterations are necessary.
     */
    while( server_read_pos < (size_t) msg_size )
    {
        TEST_ASSERT( mps_l2_read_start( &srv, &in_srv ) == 0 );
        TEST_ASSERT( in_srv.epoch == epoch_init );
        TEST_ASSERT( in_srv.type == ty_A );
        TEST_ASSERT( mbedtls_reader_get( in_srv.rd,
                                         (size_t) msg_size - server_read_pos,
                                         &buf, &sz ) == 0 );
        for( uint8_t idx = 0; idx < sz; idx++ )
            TEST_ASSERT( buf[idx] == (uint8_t) ( server_read_pos + idx ) );

        server_read_pos += sz;
        TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
        TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );
    }

exit:

    /*
     * Wrapup
     */
    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_many_epochs( int mode,
                                 int allocator_buffer_sz,
                                 int layer0_buffer_sz,
                                 int num_rounds,
                                 int real_transforms )
{
    /* This test exercises the client repeatedly sending pairs of type-A
     * and type-B records to the server, switching the epoch after each pair.
     * This test is important to test epoch-window shifting, and also epoch
     * overflow.
     *
     * Neither queueing nor pausing are needed, and hence
     * the test is valid for both TLS and DTLS. */
    int ret;

    uint8_t const ty_A = 0;
    uint8_t const ty_B = 1;

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t *buf;
    size_t sz;

    /* Layer 2 objects */
    mps_l2 cli, srv;
    mps_l2_out out_cli;
    mps_l2_in in_srv;

    mbedtls_mps_epoch_id next_cli_epoch;
    mbedtls_mps_epoch_id next_srv_epoch;

    mbedtls_mps_transform_t **epochs_c = malloc( num_rounds *
                                             sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t **epochs_s = malloc( num_rounds *
                                             sizeof( mbedtls_mps_transform_t ) );

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

    TEST_ASSERT( epochs_s != NULL && epochs_c != NULL );
    for( size_t id=0; id < (unsigned) num_rounds; id++ )
    {
        epochs_c[id] = malloc( sizeof( mbedtls_mps_transform_t ) );
        epochs_s[id] = malloc( sizeof( mbedtls_mps_transform_t ) );
        TEST_ASSERT( epochs_s[id] != NULL && epochs_c[id] != NULL );

#if !defined(TEST_SUITE_MPS_NO_SSL)
        if( real_transforms == 1 )
        {
            srand( id );
            epochs_c[id]->type = 1;
            epochs_s[id]->type = 1;
            build_transforms( &epochs_c[id]->real,
                              &epochs_s[id]->real,
                              MBEDTLS_CIPHER_AES_128_CBC,
                              MBEDTLS_MD_SHA1,
                              0, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                              mbedtls_test_rnd_std_rand, NULL );
        }
        else
#else
    ((void) real_transforms);
#endif
        {
            epochs_c[id]->type = 0;
            epochs_c[id]->mock.enabled = ( id > 0 );
            epochs_c[id]->mock.pad = id % 13 + 5;
            epochs_s[id]->type = 0;
            epochs_s[id]->mock.enabled = ( id > 0 );
            epochs_s[id]->mock.pad = id % 13 + 5;
        }
    }

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_bufsize = (size_t) layer0_buffer_sz;
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli, &cli_l1, mode,
                              0, 0, /* no queue or accumulator */
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv, &srv_l1, mode,
                              0, 0, /* no queue or accumulator */
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );

    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_A,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv, ty_B,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );

    TEST_ASSERT( mps_l2_epoch_add( &cli, epochs_c[0], &next_cli_epoch ) == 0 );
    TEST_ASSERT( mps_l2_epoch_add( &srv, epochs_s[0], &next_srv_epoch ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &cli, next_cli_epoch,
                                     MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &srv, next_srv_epoch,
                                     MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );

    for( size_t rd=0; rd < (unsigned) num_rounds - 1; rd++ )
    {
        /*
         * Client: Write something of type A to server
         */

        printf( "CLIENT ROUND %u\n", (unsigned) rd );

        out_cli.type = ty_A;
        out_cli.epoch = rd;
        TEST_ASSERT( mps_l2_write_start( &cli, &out_cli ) == 0 );

        sz = 20;
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, sz, &buf, NULL ) == 0 );
        for( uint8_t idx = 0; idx < sz; idx++ )
            buf[idx] = idx;
        TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );

        TEST_ASSERT( mps_l2_write_done( &cli ) == 0 );

        /*
         * Client: Switch epoch
         */

        /* Mark the previous epoch as unused.
         * This is implicit for TLS, but has to be done for DTLS. */
        TEST_ASSERT( mps_l2_epoch_usage( &cli, next_cli_epoch, 0 ) == 0 );

        ret = mps_l2_epoch_add( &cli, epochs_c[rd + 1],
                                &next_cli_epoch);
        if( rd + 1 >= MPS_L2_LIMIT_EPOCH )
        {
            TEST_ASSERT( ret == MPS_ERR_EPOCH_OVERFLOW );
            break;
        }
        else
            TEST_ASSERT( ret == 0 );

        TEST_ASSERT( mps_l2_epoch_usage( &cli, next_cli_epoch,
                                MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );

        /*
         * Client: Write something of type B to server
         * This exercises Layer 2 automatically closing the record for type A
         */
        out_cli.type = ty_B;
        out_cli.epoch = rd + 1;
        do {
            ret = mps_l2_write_start( &cli, &out_cli );
            TEST_ASSERT( ret == MPS_ERR_WANT_WRITE || ret == 0 );
        } while( ret != 0 );
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, sz, &buf, NULL ) == 0 );
        for( uint8_t idx = 0; idx < sz; idx++ )
            buf[idx] = idx;
        TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
        ret = mps_l2_write_done( &cli );
        TEST_ASSERT( ret == 0 );

        do {
            ret = mps_l2_write_flush( &cli );
            TEST_ASSERT( ret == MPS_ERR_WANT_WRITE || ret == 0 );
        } while( ret != 0 );

        /*
         * Server: Read first message
         */
        printf( "SERVER ROUND %u\n", (unsigned) rd );

        while( 1 )
        {
            ret = mps_l2_read_start( &srv, &in_srv );
            TEST_ASSERT( ret == MPS_ERR_WANT_READ || ret == 0 );
            if( ret != 0 )
                continue;
            TEST_ASSERT( in_srv.epoch == (mbedtls_mps_epoch_id) rd );
            TEST_ASSERT( in_srv.type == ty_A );

            ret = mbedtls_reader_get( in_srv.rd, 20, &buf, NULL );
            TEST_ASSERT( ret == MBEDTLS_ERR_READER_OUT_OF_DATA || ret == 0 );
            if( ret == 0 )
                for( uint8_t idx = 0; idx < 20; idx++ )
                    TEST_ASSERT( buf[idx] == idx );

            TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );
            if( ret == 0 )
                break;
        }

        /*
         * Server: Switch epochs
         */

        /* Mark the previous epoch as unused.
         * This is implicit for TLS, but has to be done for DTLS. */
        TEST_ASSERT( mps_l2_epoch_usage( &srv, next_srv_epoch, 0 ) == 0 );

        TEST_ASSERT( mps_l2_epoch_add( &srv, epochs_s[rd + 1],
                                       &next_srv_epoch ) == 0 );
        TEST_ASSERT( mps_l2_epoch_usage( &srv, next_srv_epoch,
                                MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );

        /*
         * Server: Read second message
         */
        while( 1 )
        {
            ret = mps_l2_read_start( &srv, &in_srv );
            TEST_ASSERT( ret == MPS_ERR_WANT_READ || ret == 0 );
            if( ret != 0 )
                continue;

            TEST_ASSERT( in_srv.epoch == (mbedtls_mps_epoch_id) ( rd + 1 ) );
            TEST_ASSERT( in_srv.type == ty_B );

            ret = mbedtls_reader_get( in_srv.rd, 20, &buf, NULL );
            TEST_ASSERT( ret == MBEDTLS_ERR_READER_OUT_OF_DATA || ret == 0 );
            if( ret == 0 )
                for( uint8_t idx = 0; idx < 20; idx++ )
                    TEST_ASSERT( buf[idx] == idx );

            TEST_ASSERT( mbedtls_reader_commit( in_srv.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &srv ) == 0 );
            if( ret == 0 )
                break;
        }
    }

exit:

    /*
     * Wrapup
     */
    TEST_ASSERT( mps_l2_free( &cli ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }

    free( epochs_s );
    free( epochs_c );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L2 */
void mbedtls_mps_l2_random( int allocator_buffer_sz,
                            int layer0_buffer_sz,
                            int num_epochs,
                            int num_types,
                            int num_chunks,
                            int max_chunk,
                            int real_transforms,
                            int write_probability,
                            int flush_probability )
{
    int ret;

    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    uint8_t *buf;

    /* Layer 2 objects */
    mps_l2 endpoint[2];

    typed_data_chunk **chunks[2];
    size_t *chunks_per_epoch[2];
    mbedtls_mps_transform_t **epochs[2];
    mbedtls_mps_epoch_id read_epoch[2];
    mbedtls_mps_epoch_id write_epoch[2];
    size_t read_chunk[2];
    size_t write_chunk[2];

    mbedtls_mps_epoch_id latest_epoch[2];

    epochs[0] = malloc( num_epochs * sizeof( mbedtls_mps_transform_t ) );
    epochs[1] = malloc( num_epochs * sizeof( mbedtls_mps_transform_t ) );
    chunks[0] = malloc( num_epochs * sizeof( typed_data_chunk* ) );
    chunks[1] = malloc( num_epochs * sizeof( typed_data_chunk* ) );
    chunks_per_epoch[0] = malloc( num_epochs * sizeof( size_t ) );
    chunks_per_epoch[1] = malloc( num_epochs * sizeof( size_t ) );

    TEST_ASSERT( chunks[0] != NULL && chunks_per_epoch[0] != NULL );
    TEST_ASSERT( chunks[1] != NULL && chunks_per_epoch[1] != NULL );
    TEST_ASSERT( epochs[0] != NULL && epochs[1] != NULL );

    for( size_t id=0; id < (unsigned) num_epochs; id++ )
    {
        size_t chunks_in_epoch;

        epochs[0][id] = malloc( sizeof( mbedtls_mps_transform_t ) );
        epochs[1][id] = malloc( sizeof( mbedtls_mps_transform_t ) );
        TEST_ASSERT( epochs[0][id] != NULL && epochs[1][id] != NULL );

#if !defined(TEST_SUITE_MPS_NO_SSL)
        if( real_transforms == 1 )
        {
            srand( id );
            epochs[0][id]->type = 1;
            epochs[1][id]->type = 1;
            build_transforms( &epochs[0][id]->real,
                              &epochs[1][id]->real,
                              MBEDTLS_CIPHER_AES_128_CBC,
                              MBEDTLS_MD_SHA1,
                              0, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                              mbedtls_test_rnd_std_rand, NULL );
        }
        else
#else
    ((void) real_transforms);
#endif
        {
            epochs[0][id]->type = 0;
            epochs[0][id]->mock.enabled = ( id > 0 );
            epochs[0][id]->mock.pad = 10;
            epochs[1][id]->type = 0;
            epochs[1][id]->mock.enabled = ( id > 0 );
            epochs[1][id]->mock.pad = 10;
        }

        for( size_t k=0; k<2; k++ )
        {
            /* Pick a random number of chunks per epoch */
            chunks_in_epoch = ( rand() % num_chunks ) + 1;
            chunks_per_epoch[k][id] = chunks_in_epoch;
            chunks[k][id] = malloc( sizeof( typed_data_chunk ) * chunks_in_epoch );
            TEST_ASSERT( chunks[k][id] != NULL );
            for( size_t chunk=0; chunk < chunks_in_epoch; chunk++ )
            {
                size_t cur_chunk_size;
                cur_chunk_size = ( rand() % max_chunk ) + 1;

                chunks[k][id][chunk].type = rand() % num_types;
                chunks[k][id][chunk].buf = malloc( cur_chunk_size );
                chunks[k][id][chunk].len = cur_chunk_size;
                chunks[k][id][chunk].read_progress = 0;
                chunks[k][id][chunk].send_progress = 0;
                TEST_ASSERT( chunks[k][id][chunk].buf != NULL );

                mbedtls_test_rnd_std_rand( NULL, chunks[k][id][chunk].buf, cur_chunk_size );
            }
        }
    }

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &endpoint[0], &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &endpoint[1], &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &endpoint[0],
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &endpoint[1],
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );

    TEST_ASSERT( num_types <= 64 );
    for( size_t ty=0; ty < (unsigned) num_types; ty++ )
    {
        TEST_ASSERT( mps_l2_config_add_type( &endpoint[0], ty,
                                             MPS_L2_SPLIT_ENABLED,
                                             MPS_L2_PACK_ENABLED,
                                             MPS_L2_EMPTY_FORBIDDEN ) == 0 );
        TEST_ASSERT( mps_l2_config_add_type( &endpoint[1], ty,
                                             MPS_L2_SPLIT_ENABLED,
                                             MPS_L2_PACK_ENABLED,
                                             MPS_L2_EMPTY_FORBIDDEN ) == 0 );
    }

    TEST_ASSERT( mps_l2_epoch_add( &endpoint[0], epochs[0][0],
                                   &latest_epoch[0] ) == 0 );
    TEST_ASSERT( latest_epoch[0] == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &endpoint[0], latest_epoch[0],
                                  MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );
    read_epoch[0] = write_epoch[0] = latest_epoch[0];

    TEST_ASSERT( mps_l2_epoch_add( &endpoint[1], epochs[1][0],
                                   &latest_epoch[1] ) == 0 );
    TEST_ASSERT( latest_epoch[1] == 0 );
    TEST_ASSERT( mps_l2_epoch_usage( &endpoint[1], latest_epoch[1],
                                  MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );
    read_epoch[1] = write_epoch[1] = latest_epoch[1];


    write_chunk[0] = 0;
    write_chunk[1] = 0;
    read_chunk[0]  = 0;
    read_chunk[1]  = 0;

    while( read_epoch[0] < num_epochs ||
           read_epoch[1] < num_epochs )
    {
        size_t self;
        size_t peer;
        size_t read_or_write;

        self = rand() % 2;
        peer = self ^ 1;

        read_or_write = rand() % 100;
        if( read_or_write >= (unsigned) write_probability )
        {
            /* Reading */

            mbedtls_mps_epoch_id epoch;
            size_t chunk_num;
            typed_data_chunk *chunk;
            mps_l2_in in;
            size_t data_remaining;
            size_t data_requested;
            size_t data_obtained;

            epoch = read_epoch[self];
            chunk_num = read_chunk[self];

            /* If we have already read everything, skip. */
            if( epoch == num_epochs )
            {
                printf( "SKIP READ, REACHED FINAL EPOCH %u\n",
                        (unsigned) epoch );
                continue;
            }

            printf( "[%u] READ, EPOCH %u, CHUNK %u / %u\n",
                    (unsigned) self, (unsigned) epoch,
                    (unsigned) ( chunk_num + 1 ),
                    (unsigned) chunks_per_epoch[peer][epoch] );

            /* Check if we need to switch the epoch */
            if( chunk_num == chunks_per_epoch[peer][epoch] )
            {
                typed_data_chunk *new_chunk = NULL;

                /* Need to switch the epoch */
                chunk_num = 0;
                epoch++;

                if( epoch == num_epochs )
                {
                    read_epoch[self] = epoch;
                    read_chunk[self] = chunk_num;
                    printf( "SKIP READ, REACHED FINAL EPOCH %u\n",
                            (unsigned) epoch );
                    continue;
                }

                printf( "[%u] SWITCH TO READ EPOCH %u, WRITE EPOCH %u\n",
                        (unsigned) self, (unsigned) epoch,
                        (unsigned) write_epoch[ self ] );

                /* Check if have already added the epoch for writing. */
                if( epoch > write_epoch[self] )
                {
                    /* No, need to add epoch */
                    ret = mps_l2_epoch_add( &endpoint[self],
                                            epochs[self][epoch],
                                            &latest_epoch[self] );
                    TEST_ASSERT( ret == 0                             ||
                                 ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED );
                    if( ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED )
                        continue;

                    TEST_ASSERT( epoch == latest_epoch[self] );
                }

                TEST_ASSERT( mps_l2_epoch_usage( &endpoint[self],
                                                 epoch,
                                                 MPS_EPOCH_READ ) == 0 );

                printf( "[%u] SWITCHED TO READ EPOCH %u\n",
                        (unsigned) self, (unsigned) epoch );

                read_epoch[self] = epoch;
                read_chunk[self] = chunk_num;

                new_chunk = &chunks[peer][epoch][chunk_num];
                new_chunk->read_progress = 0;
            }

            chunk = &chunks[peer][epoch][chunk_num];

            TEST_ASSERT( chunk->read_progress <= chunk->send_progress );
            data_remaining = chunk->send_progress - chunk->read_progress;
            if( data_remaining != 0 )
                data_requested = ( rand() % data_remaining ) + 1;
            else
                data_requested = 0;

            ret = mps_l2_read_start( &endpoint[self], &in );
            TEST_ASSERT( ret == MPS_ERR_WANT_READ || ret == 0 );
            if( ret != 0 )
            {
                printf( "WANT_READ\n" );
                continue;
            }

            printf( " READ START DONE\n" );

            TEST_ASSERT( in.type == chunk->type );
            ret = mbedtls_reader_get( in.rd, data_requested, &buf,
                                      &data_obtained );
            TEST_ASSERT( ret == 0 );
            TEST_ASSERT( memcmp( buf, chunk->buf + chunk->read_progress,
                                 data_obtained ) == 0 );
            chunk->read_progress += data_obtained;

            TEST_ASSERT( mbedtls_reader_commit( in.rd ) == 0 );
            TEST_ASSERT( mps_l2_read_done( &endpoint[self] ) == 0 );

            printf( "     PROGRESS %u / %u\n",
                    (unsigned) chunk->read_progress, (unsigned) chunk->len );

            /* Check if we're at the end of the chunk */
            if( chunk->read_progress == chunk->len )
            {
                /* Switch to the next chunk */
                typed_data_chunk *new_chunk = NULL;

                chunk_num++;
                read_chunk[self] = chunk_num;

                /* Check if we need to switch the epoch */
                if( chunk_num == chunks_per_epoch[peer][epoch] )
                    continue;

                new_chunk = &chunks[peer][epoch][chunk_num];
                new_chunk->read_progress = 0;
            }
        }
        else
        {
            /* Writing */

            uint8_t flush_or_write;

            mbedtls_mps_epoch_id epoch;
            size_t chunk_num;
            typed_data_chunk *chunk;
            mps_l2_out out;
            size_t data_remaining;
            size_t data_requested;
            size_t data_obtained;
            size_t tmp_send_progress;

            /* If we have already written everything, skip. */
            epoch = write_epoch[self];
            chunk_num = write_chunk[self];

            /* Choose between flushing and writing */
            flush_or_write = rand() % 100;
            if( flush_or_write < (unsigned) flush_probability )
            {
                /* Flushing */
                printf( "[%u] FLUSHING, EPOCH %u, CHUNK %u\n",
                        (unsigned) self, (unsigned) epoch,
                        (unsigned) chunk_num );
                ret = mps_l2_write_flush( &endpoint[self] );
                TEST_ASSERT( ret == MPS_ERR_WANT_WRITE || ret == 0 );
                continue;
            }

            if( epoch == num_epochs )
            {
                printf( "SKIP WRITE, REACHED FINAL EPOCH %u\n",
                        (unsigned) epoch );
                continue;
            }

            printf( "[%u] WRITE, EPOCH %u, CHUNK %u / %u\n",
                    (unsigned) self, (unsigned) epoch,
                    (unsigned) ( chunk_num + 1 ),
                    (unsigned) chunks_per_epoch[self][epoch] );

            /* Check if we need to switch the epoch */
            if( chunk_num == chunks_per_epoch[self][epoch] )
            {
                typed_data_chunk *new_chunk = NULL;

                /* Need to switch the epoch */
                chunk_num = 0;
                epoch++;

                if( epoch == num_epochs )
                {
                    write_epoch[self] = epoch;
                    write_chunk[self] = chunk_num;
                    printf( "SKIP WRITE, REACHED FINAL EPOCH %u\n",
                            (unsigned) epoch );
                    continue;
                }

                printf( "[%u] SWITCH TO WRITE EPOCH %u, READ EPOCH %u, LATEST %u\n",
                        (unsigned) self, (unsigned) epoch,
                        (unsigned) read_epoch[self],
                        (unsigned) latest_epoch[self] );

                /* Check if have already added the epoch for writing. */
                if( epoch > read_epoch[self] )
                {
                    /* No, need to add epoch */
                    ret = mps_l2_epoch_add( &endpoint[self],
                                            epochs[self][epoch],
                                            &latest_epoch[self] );
                    TEST_ASSERT( ret == 0                             ||
                                 ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED );
                    if( ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED )
                        continue;

                    TEST_ASSERT( epoch == latest_epoch[self] );
                }

                TEST_ASSERT( mps_l2_epoch_usage( &endpoint[self],
                                                 epoch,
                                                 MPS_EPOCH_WRITE ) == 0 );

                printf( "[%u] SWITCHED TO WRITE EPOCH %u\n",
                        (unsigned) self, (unsigned) epoch );

                write_epoch[self] = epoch;
                write_chunk[self] = chunk_num;

                new_chunk = &chunks[self][epoch][chunk_num];
                new_chunk->send_progress = 0;
            }

            chunk = &chunks[self][epoch][chunk_num];

            printf( "[%u] WRITE, EPOCH %u, CHUNK %u / %u, WRITE %u / %u\n",
                    (unsigned) self, (unsigned) epoch,
                    (unsigned) ( chunk_num + 1 ),
                    (unsigned) chunks_per_epoch[self][epoch],
                    (unsigned) chunk->send_progress,
                    (unsigned) chunk->len );

            out.type = chunk->type;
            out.epoch = epoch;
            ret = mps_l2_write_start( &endpoint[self], &out );
            TEST_ASSERT( ret == MPS_ERR_WANT_WRITE || ret == 0 );
            if( ret != 0 )
                continue;

            tmp_send_progress = chunk->send_progress;
            TEST_ASSERT( tmp_send_progress < chunk->len );

            /* Make use of the writer in a random way */
            while( tmp_send_progress < chunk->len )
            {
                data_remaining = chunk->len - tmp_send_progress;
                data_requested = ( rand() % data_remaining ) + 1;

                printf( "    REQUEST %u\n", (unsigned) data_requested );
                ret = mbedtls_writer_get( out.wr, data_requested, &buf,
                                          &data_obtained );
                TEST_ASSERT( ret == 0 ||
                             ret == MBEDTLS_ERR_WRITER_OUT_OF_DATA );
                if( ret == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                    break;

                printf( "    WRITE %u\n", (unsigned) data_obtained );
                memcpy( buf, chunk->buf + tmp_send_progress, data_obtained );
                tmp_send_progress += data_obtained;

                /* Don't always commit */
                if( rand() % 2 )
                {
                    printf( "    COMMIT\n" );
                    TEST_ASSERT( mbedtls_writer_commit( out.wr ) == 0 );
                    chunk->send_progress = tmp_send_progress;
                }

                if( rand() % 5 == 0 )
                    break;
            }

            TEST_ASSERT( mps_l2_write_done( &endpoint[self] ) == 0 );

            printf( "     PROGRESS %u / %u\n",
                    (unsigned) chunk->send_progress, (unsigned) chunk->len );

            /* Check if we're at the end of the chunk */
            if( chunk->send_progress == chunk->len )
            {
                /* Switch to the next chunk */
                typed_data_chunk *new_chunk = NULL;

                chunk_num++;
                write_chunk[self] = chunk_num;

                /* Check if we need to switch the epoch */
                if( chunk_num == chunks_per_epoch[self][epoch] )
                    continue;

                new_chunk = &chunks[self][epoch][chunk_num];
                new_chunk->send_progress = 0;
            }
        }
    }

exit:

    /*
     * Wrapup
     */

    mps_l2_free( &endpoint[0] );
    mps_l2_free( &endpoint[1] );

    for( size_t id=0; id < (unsigned) num_epochs; id++ )
    {
        for( size_t k=0; k<2; k++ )
        {
            size_t chunks_in_epoch = chunks_per_epoch[k][id];
            for( size_t chunk=0; chunk < chunks_in_epoch; chunk++ )
                free( chunks[k][id][chunk].buf );
            free( chunks[k][id] );
        }
    }

    free( chunks_per_epoch[ 0 ] );
    free( chunks_per_epoch[ 1 ] );
    free( chunks[0] );
    free( chunks[1] );
    free( epochs[0] );
    free( epochs[1] );

    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );

}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_basic_handshake(
          int mode,
          int allocator_buffer_sz,
          int layer0_buffer_sz,
          int rec_sz,
          int aborted_before,
          int real_transforms,
          int length_known,
          int multiple_fetch,
          int intermediate_commit,
          int partial_commit )
{
    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mps_l3_handshake_out hs_out;
    mps_l3_handshake_in hs_in;

    size_t additional_fetch = partial_commit ? 10 : 0;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    mps_l0_send_t *cli_wr,  *srv_wr;
    mps_l0_recv_t *cli_rcv, *srv_rcv;

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    /* Initialize Layer 0 mock objects */
    if( mode == MPS_L2_MODE_STREAM )
    {
        layer0_bufsize = (size_t) layer0_buffer_sz;
        TEST_ASSERT( layer0_init( &s2c ) == 0 );
        TEST_ASSERT( layer0_init( &c2s ) == 0 );

        cli_wr  = &layer0_write_cli;
        cli_rcv = &layer0_read_cli;
        srv_wr  = &layer0_write_srv;
        srv_rcv = &layer0_read_srv;
    }
    else
    {
        TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
        TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

        cli_wr  = &layer0_dgram_write_cli;
        cli_rcv = &layer0_dgram_read_cli;
        srv_wr  = &layer0_dgram_write_srv;
        srv_rcv = &layer0_dgram_read_srv;
    }

    ((void) rec_sz);

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, mode, &cli_alloc,
                              cli_wr, cli_rcv ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, mode, &srv_alloc,
                              srv_wr, srv_rcv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, mode,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, mode,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, mode ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, mode ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Start but abort writing handshake message, if requested
     */

    if( aborted_before != 0)
    {
        hs_out.epoch = 0;
        hs_out.type = 12;

        if( mode == MPS_L3_MODE_STREAM )
        {
            if( length_known == 0 )
            {
                hs_out.frag_offset = 0;
                hs_out.frag_len    = 10;
                hs_out.len         = 20;
            }
            else
            {
                hs_out.frag_offset = 0;
                hs_out.frag_len    = MPS_L3_LENGTH_UNKNOWN;
                hs_out.len         = MPS_L3_LENGTH_UNKNOWN;
            }
        }
        else
        {
            if( length_known == 2 )
            {
                hs_out.frag_offset = 10;
                hs_out.frag_len    = 20;
                hs_out.len         = 40;
            }
            else if( length_known == 1 )
            {
                hs_out.frag_offset = 10;
                hs_out.frag_len    = MPS_L3_LENGTH_UNKNOWN;
                hs_out.len         = 40;
            }
            else
            {
                hs_out.frag_offset = 0;
                hs_out.frag_len    = MPS_L3_LENGTH_UNKNOWN;
                hs_out.len         = MPS_L3_LENGTH_UNKNOWN;
            }
        }

        TEST_ASSERT( mps_l3_write_handshake( &cli,
                                             &hs_out ) == 0 );

        if( aborted_before == 1 )
        {
            TEST_ASSERT( mbedtls_writer_get_ext( hs_out.wr_ext, 10,
                                                 &tmp, NULL ) == 0 );

            TEST_ASSERT( mps_l3_write_abort_handshake( &cli ) == 0 );
        }
        else if( aborted_before == 2 )
        {
            TEST_ASSERT( mbedtls_writer_get_ext( hs_out.wr_ext, 10,
                                                 &tmp, NULL ) == 0 );
            TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.wr_ext ) == 0 );

            /* We shouldn't be allowed to abort once we have
             * committed something. */
            TEST_ASSERT( mps_l3_write_abort_handshake( &cli ) ==
                         MPS_ERR_INTERNAL_ERROR );

            goto exit;
        }
    }

    /*
     * Client: Write handshake message to server
     */

    hs_out.epoch = 0;
    hs_out.type = 12;

    if( mode == MPS_L3_MODE_STREAM )
    {
        if( length_known )
        {
            hs_out.frag_offset = 0;
            hs_out.frag_len    = 10;
            hs_out.len         = 20;
        }
        else
        {
            hs_out.frag_offset = 0;
            hs_out.frag_len    = MPS_L3_LENGTH_UNKNOWN;
            hs_out.len         = MPS_L3_LENGTH_UNKNOWN;
        }
    }
    else
    {
        if( length_known == 2 )
        {
            hs_out.frag_offset = 10;
            hs_out.frag_len    = 20;
            hs_out.len         = 40;
        }
        else if( length_known == 1 )
        {
            hs_out.frag_offset = 10;
            hs_out.frag_len    = MPS_L3_LENGTH_UNKNOWN;
            hs_out.len         = 40;
        }
        else
        {
            hs_out.frag_offset = 0;
            hs_out.frag_len    = MPS_L3_LENGTH_UNKNOWN;
            hs_out.len         = MPS_L3_LENGTH_UNKNOWN;
        }
    }

    TEST_ASSERT( mps_l3_write_handshake( &cli,
                                         &hs_out ) == 0 );

    if( multiple_fetch )
    {
        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.wr_ext, 10, &tmp, NULL ) == 0 );
        for( size_t idx=0; idx<10; idx++ )
            tmp[idx] = (unsigned char) idx;

        if( intermediate_commit )
            TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.wr_ext )  == 0 );

        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.wr_ext, 10 + additional_fetch,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx< 10 + additional_fetch ; idx++ )
            tmp[idx] = (unsigned char) ( 10 + idx );
    }
    else
    {
        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.wr_ext,
                                             20 + additional_fetch,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx<20 + additional_fetch; idx++ )
            tmp[idx] = (unsigned char) idx;
    }

    if( !partial_commit )
    {
        /* Commit and update state */
        TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.wr_ext ) == 0 );
    }
    else
    {
        /* Commit and update state */
        TEST_ASSERT( mbedtls_writer_commit_partial_ext( hs_out.wr_ext,
                                                    additional_fetch ) == 0 );
    }

    /* Check that writer is blocked. */
    if( !length_known && partial_commit )
    {
        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.wr_ext, 10, &tmp, NULL ) ==
                     MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    }

    /* Dispatch handshake message */
    TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

    /*
     * Server: Read handshake message from client
     */

    TEST_ASSERT( mps_l3_read( &srv ) == MBEDTLS_MPS_MSG_HS );

    TEST_ASSERT( mps_l3_read_handshake( &srv, &hs_in ) == 0 );
    TEST_ASSERT( hs_in.epoch == 0 );
    TEST_ASSERT( hs_in.type == 12 );

    if( mode == MPS_L3_MODE_STREAM )
    {
        TEST_ASSERT( hs_in.len == 20 );
    }
    else
    {
        if( length_known == 1 || length_known == 2 )
        {
            TEST_ASSERT( hs_in.len         == 40 );
            TEST_ASSERT( hs_in.frag_len    == 20 );
            TEST_ASSERT( hs_in.frag_offset == 10 );
        }
        else
        {
            TEST_ASSERT( hs_in.len         == 20 );
            TEST_ASSERT( hs_in.frag_len    == 20 );
            TEST_ASSERT( hs_in.frag_offset == 0  );
        }
    }

    /* Fetch next chunk of incoming data */
    TEST_ASSERT( mbedtls_reader_get_ext( hs_in.rd_ext, 20, &tmp, NULL ) == 0 );

    /* Process incoming data */
    for( size_t idx=0; idx<10; idx++ )
        TEST_ASSERT( tmp[idx] == (unsigned char) idx );

    /* Commit last incoming chunk and update state */
    TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.rd_ext ) == 0 );

    /* Signal that message has been processed. */
    TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );

    /* We should have consumed the entire record - check this.
     * For example, this will catch if we messed up
     * forwarding a partial commit from the extended writer
     * to the writer: Say we start writing a handshake fragment
     * of unspecified length, we write 30 bytes and we partially
     * commit 20 to the extended writer, as above. If this partial
     * commit is not properly forwarded to the underlying writer,
     * but instead all 30 bytes are committed, then we will write
     * a handshake fragment of length 20, followed by 10 more
     * garbage bytes in the same record. This happened before
     * and was not caught by the test. Attempting to read another
     * message will catch it, because the remaining 10 bytes
     * will be interpreted as a handshake header and lead to
     * another handshake message being opened. */
    TEST_ASSERT( mps_l3_read( &srv ) == MPS_ERR_WANT_READ );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &cli ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );

    if( mode == MPS_L1_MODE_STREAM )
    {
        layer0_free( &s2c );
        layer0_free( &c2s );
    }
    else
    {
        layer0_dgram_free( &s2c_d );
        layer0_dgram_free( &c2s_d );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_bad_msg( int variant )
{
    /* This test exercises the behavior of Layer 3 for DTLS
     * in case it receives a
     * - partial handshake header
     * - bad handshake header (frag_offset + frag_len > len )
     * - partial alert message
     * - bad CCS message
     */

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli;
    mps_l3 srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mps_l2_out out_cli;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, 100 );
    mps_alloc_init( &srv_alloc, 100 );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L2_MODE_DATAGRAM,
                              &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L2_MODE_DATAGRAM,
                              &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_DATAGRAM,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_DATAGRAM,
                              0, 0, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_CCS,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_CCS,
                                         MPS_L2_SPLIT_DISABLED,
                                         MPS_L2_PACK_ENABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, MPS_L3_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );

    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, MPS_L3_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write an invalid handshake header to server.
     */

    if( variant == 0 )
    {
        /* Send a record of handshake type and length 1. */

        out_cli.type  = MBEDTLS_MPS_MSG_HS;
        out_cli.epoch = cli_epoch;
        TEST_ASSERT( mps_l2_write_start( &cli_l2, &out_cli ) == 0 );
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 1, &tmp, NULL ) == 0 );
        tmp[0] = 1;
        TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    }
    else if( variant == 1 )
    {
        size_t const dtls_hs_hdr_len         = 13;
        size_t const dtls_hs_len_offset      = 1;
        size_t const dtls_hs_frag_off_offset = 7;
        size_t const dtls_hs_frag_len_offset = 10;
        /* Send a handshake header with frag_offset + frag_len > len */

        out_cli.type  = MBEDTLS_MPS_MSG_HS;
        out_cli.epoch = cli_epoch;
        TEST_ASSERT( mps_l2_write_start( &cli_l2, &out_cli ) == 0 );
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, dtls_hs_hdr_len,
                                         &tmp, NULL ) == 0 );

        /* Length 42 */
        tmp[ dtls_hs_len_offset + 0 ] =  0;
        tmp[ dtls_hs_len_offset + 1 ] =  0;
        tmp[ dtls_hs_len_offset + 2 ] = 42;

        /* Fragment offset 10 */
        tmp[ dtls_hs_frag_off_offset + 0 ] =  0;
        tmp[ dtls_hs_frag_off_offset + 1 ] =  0;
        tmp[ dtls_hs_frag_off_offset + 2 ] = 10;

        /* Fragment length 100 */
        tmp[ dtls_hs_frag_len_offset + 0 ] =   0;
        tmp[ dtls_hs_frag_len_offset + 1 ] =   0;
        tmp[ dtls_hs_frag_len_offset + 2 ] = 100;

        TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    }
    else if( variant == 2 )
    {
        /* Send a record of alert type and length 1. */

        out_cli.type  = MBEDTLS_MPS_MSG_ALERT;
        out_cli.epoch = cli_epoch;
        TEST_ASSERT( mps_l2_write_start( &cli_l2, &out_cli ) == 0 );
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 1, &tmp, NULL ) == 0 );
        tmp[0] = 1;
        TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    }
    else if( variant == 3 )
    {
        /* Send a CCS record of length 1 with value != 0 */

        out_cli.type  = MBEDTLS_MPS_MSG_CCS;
        out_cli.epoch = cli_epoch;
        TEST_ASSERT( mps_l2_write_start( &cli_l2, &out_cli ) == 0 );
        TEST_ASSERT( mbedtls_writer_get( out_cli.wr, 1, &tmp, NULL ) == 0 );
        tmp[0] = 42;
        TEST_ASSERT( mbedtls_writer_commit( out_cli.wr ) == 0 );
    }

    TEST_ASSERT( mps_l2_write_done( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_write_flush( &cli_l2 ) == 0 );

    /*
     * Server: Read handshake message from client
     */

    TEST_ASSERT( mps_l3_read( &srv ) == MPS_ERR_BAD_MSG );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_handshake_gradual( int allocator_buffer_sz,
                                       int layer0_buffer_sz,
                                       int rec_sz,
                                       int real_transforms,
                                       int num_msgs,
                                       int pause_after_header )
{
    int res;
    size_t msgs_remaining;

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    int send_state;
    int recv_state;

    mps_l3_handshake_out hs_out;
    mps_l3_handshake_in hs_in;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write handshake message to server
     */

    /* This is an example of how gradual handshake
     * message writing can be implemented:
     * - A state variable (here `send_state`) keeps track of which
     *   parts of the message have already been written.
     * - In the beginning as well as when continuing a write,
     *   a write-request is filed to Layer 3, returning a writer
     *   object on success.
     * - The writer object is used to write the next chunk of outgoing
     *   data, committing and updating the state afterwards. If not
     *   enough space is available to serve the write request, the writing
     *   is paused.
     *
     * This works if either of the following conditions holds:
     * (a) The Layer 1 write-buffer is large enough to hold the entire
     *     message at once.
     * (b) The writer's queue is at least as large as the largest chunk of
     *     data written in between two subsequent commits -- in our example,
     *     this is 10. If that's the case, then the Layer 1 write-buffer size
     *     can be arbitrary, as long as it can hold at least a protected record
     *     of plaintext size 1 byte.
     *
     * This way, speed and code-size can be traded for RAM usage by using
     * gradual message writing.
     */

    msgs_remaining = num_msgs;
    while( msgs_remaining-- )
    {
        /* TODO: It's planned to move the integral state variable into the
         *       extended writer object. */
        send_state = 0;
        while( 1 )
        {
            int pause = 0;

            /* This is uniform for initial writing and write continuations:
             * Just request a handshake write from Layer 3. If a handshake write
             * has been paused before, Layer 3 will attempt to continue it. */
            hs_out.epoch = 0;
            hs_out.type = 12;
            hs_out.len = 8;
            res = mps_l3_write_handshake( &cli, &hs_out );
            TEST_ASSERT( res == 0 || res == MPS_ERR_WANT_WRITE );
            if( res != 0 )
                continue;

            /*
             * Actual message writing code: In production-code,
             * this will be a separate function for each of the
             * handshake messages.
             *
             * The basic structure, however, will always be the same:
             * - Check the status and jump ahead to the respective place in
             *   the writing routine.
             * - Continue the writing from there, comitting the written data
             *   at each point of pre-emption. The more points of pre-emption
             *   and, hence, the smaller the chunk-sizes are, the less memory
             *   is needed by the writer internally.
             * - Pause and return if not enough data is available.
             */

            switch( send_state )
            {
                case 0:

                    if( pause_after_header )
                    {
                        pause      = 1;
                        send_state = 1;
                        break;
                    }

                case 1:

                    /* Ask for outbuffer to write next chunk of data */
                    res = mbedtls_writer_get_ext( hs_out.wr_ext, 4, &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_WRITER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Write contents */
                    for( size_t idx=0; idx<4; idx++ )
                        tmp[idx] = (unsigned char)( msgs_remaining + idx );

                    /* Commit and update state */
                    TEST_ASSERT( mbedtls_writer_commit_ext(
                                     hs_out.wr_ext ) == 0 );
                    send_state = 2;

                    /* Attempt to finish the writing -- should give an error
                     * because we have initially specified how much we intend
                     * to write. */
                    TEST_ASSERT( mps_l3_dispatch( &cli ) ==
                                 MPS_ERR_UNFINISHED_HS_MSG );

                case 2:

                    /* Ask for outbuffer to write next chunk of data */
                    res = mbedtls_writer_get_ext( hs_out.wr_ext, 4,
                                                  &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_WRITER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Write contents */
                    for( size_t idx=0; idx<4; idx++ )
                        tmp[idx] = (unsigned char)( 4 + msgs_remaining + idx );

                    /* Commit and update state */
                    TEST_ASSERT( mbedtls_writer_commit_ext(
                                     hs_out.wr_ext ) == 0 );
                    send_state = 3;

                default:
                    break;
            }

            if( pause == 1 )
            {
                TEST_ASSERT( mps_l3_pause_handshake( &cli ) == 0 );
                TEST_ASSERT( mps_l3_flush( &cli ) == 0 );
            }
            else
            {
                break;
            }
        }

        TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
    }

    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

    /*
     * Server: Read handshake message from client
     */

    /* This is an example of how gradual handshake
     * message reading can be implemented:
     * - A state variable (here `read_state`) keeps track of which
     *   parts of the message have already been read.
     * - In the beginning as well as when continuing a read,
     *   a read-request is filed to Layer 3, returning a handshake
     *   reader on success.
     * - The reader object is used to fetch the next chunk of incoming
     *   data, committing and updating the state afterwards.
     *   If not enough data is available in the reader, the reading
     *   is paused, and the reader's internal accumulator will ensure
     *   that the request can be served when the read continues.
     *
     * This works if either of the following conditions hold:
     * (a) Record are sent unfragmented and the Layer 1 read-buffer is
     *     large enough to hold them at once.
     * (b) The reader's accumulator is at least as large as the largest
     *     chunk of incoming data fetched and processed between two
     *     subsequent commits. If that's the case, then the Layer 1 read-buffer
     *     size can be arbitrary, as long as it's capable of holding the records
     *     sent by the peer.
     *
     * This way, speed and code-size can be traded for RAM usage by using
     * gradual message reading.
     */
    msgs_remaining = num_msgs;
    while( msgs_remaining-- )
    {
        recv_state = 0;
        while( 1 )
        {
            int pause = 0;

            res = mps_l3_read( &srv );
            TEST_ASSERT( res == MBEDTLS_MPS_MSG_HS ||
                         res == MPS_ERR_WANT_READ );
            if( res < 0 )
                continue;

            TEST_ASSERT( mps_l3_read_handshake( &srv, &hs_in ) == 0 );
            TEST_ASSERT( hs_in.epoch == 0 );
            TEST_ASSERT( hs_in.type == 12 );
            TEST_ASSERT( hs_in.len == 8 );

            switch( recv_state )
            {
                case 0:

                    /* Fetch next chunk of incoming data */
                    res = mbedtls_reader_get_ext( hs_in.rd_ext, 4, &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_READER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_READER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Process incoming data */
                    for( size_t idx=0; idx<4; idx++ )
                        TEST_ASSERT( tmp[idx] ==
                                     (uint8_t)( msgs_remaining + idx ) );

                    /* Commit last incoming chunk and update state */
                    TEST_ASSERT( mbedtls_reader_commit_ext(
                                     hs_in.rd_ext ) == 0 );
                    recv_state = 1;

                    /* Attempt to finish the reading -- should give an error because
                     * we know how large the message is in total.. */
                    TEST_ASSERT( mps_l3_read_consume( &srv ) ==
                                 MPS_ERR_UNFINISHED_HS_MSG );

                    /* `break` is deliberately omitted here as
                     *  we want to continue processing. */

                case 1:

                    /* Fetch next chunk of incoming data */
                    res = mbedtls_reader_get_ext( hs_in.rd_ext, 4,
                                                  &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_READER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_READER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Process incoming data */
                    for( size_t idx=0; idx<4; idx++ )
                        TEST_ASSERT( tmp[idx] ==
                                     (uint8_t) ( 4 + msgs_remaining + idx ) );

                    /* Commit last incoming chunk and update state */
                    TEST_ASSERT( mbedtls_reader_commit_ext(
                                     hs_in.rd_ext ) == 0 );
                    recv_state = 2;

                default:
                    break;
            }

            if( pause == 1 )
                TEST_ASSERT( mps_l3_read_pause_handshake( &srv ) == 0 );
            else
                break;
        }

        TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &cli ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_basic_application( int allocator_buffer_sz,
                                       int layer0_buffer_sz,
                                       int rec_sz,
                                       int real_transforms )
{
    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mps_l3_app_out app_out;
    mps_l3_app_in app_in;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_APP,
                                         1, 0, 1) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_APP,
                                         0, 1, 1 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write application data to server
     */

    app_out.epoch = 0;
    TEST_ASSERT( mps_l3_write_app( &cli, &app_out ) == 0 );

    /* Ask for outbuffer to write next chunk of data */
    TEST_ASSERT( mbedtls_writer_get( app_out.wr, 10, &tmp, NULL ) == 0 );

    /* Write contents */
    for( size_t idx=0; idx<10; idx++ )
        tmp[idx] = (unsigned char) idx;

    /* Commit and update state */
    TEST_ASSERT( mbedtls_writer_commit( app_out.wr ) == 0 );

    /* Dispatch application data message */
    TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

    /*
     * Server: Read application data from client
     */

    TEST_ASSERT( mps_l3_read( &srv ) == MBEDTLS_MPS_MSG_APP );

    TEST_ASSERT( mps_l3_read_app( &srv, &app_in ) == 0 );

    /* Fetch next chunk of incoming data */
    TEST_ASSERT( mbedtls_reader_get( app_in.rd , 10, &tmp, NULL ) == 0 );

    /* Process incoming data */
    for( size_t idx=0; idx<10; idx++ )
        TEST_ASSERT( tmp[idx] == (unsigned char) idx );

    /* Commit last incoming chunk and update state */
    TEST_ASSERT( mbedtls_reader_commit( app_in.rd ) == 0 );

    /* Signal that message has been processed. */
    TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &cli ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_basic_alert( int allocator_buffer_sz,
                                 int layer0_buffer_sz,
                                 int rec_sz,
                                 int real_transforms,
                                 int handle_fragmentation,
                                 int num_alerts,
                                 int alert_merging )
{
    int res;
    size_t alerts_remaining;

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli, srv;

    mps_l3_alert_out alert_out;
    mps_l3_alert_in alert_in;

    uint8_t const alert_type = 0xc;
    uint8_t const alert_level = 0x1a;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         handle_fragmentation ?
                                           MPS_L2_SPLIT_ENABLED :
                                           MPS_L2_SPLIT_DISABLED,
                                         alert_merging ?
                                           MPS_L2_PACK_ENABLED :
                                           MPS_L2_PACK_DISABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         handle_fragmentation ?
                                           MPS_L2_SPLIT_ENABLED :
                                           MPS_L2_SPLIT_DISABLED,
                                         alert_merging ?
                                           MPS_L2_PACK_ENABLED :
                                           MPS_L2_PACK_DISABLED,
                                         MPS_L2_EMPTY_ALLOWED ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write alert message to server
     */

    alerts_remaining = (size_t) num_alerts;
    while( alerts_remaining-- )
    {
        int retry = 0;
        alert_out.epoch = 0;
        while( 1 )
        {
            TEST_ASSERT( retry <= 1 );

            res = mps_l3_write_alert( &cli,
                                          &alert_out );
            TEST_ASSERT( res == 0 || res == MPS_ERR_WANT_WRITE );
            if( res == 0 )
                break;

            retry++;
        }

        *alert_out.level = (uint8_t)( alert_level + alerts_remaining );
        *alert_out.type = (uint8_t)( alert_type + alerts_remaining );

        /* Dispatch application data message */
        TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
    }

    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

    /*
     * Server: Read alert message from client
     */

    alerts_remaining = (size_t) num_alerts;
    while( alerts_remaining-- )
    {
        int retry = 0;

        while( 1 )
        {
            TEST_ASSERT( retry <= 1 );
            res = mps_l3_read( &srv );
            TEST_ASSERT( res == MPS_ERR_WANT_READ ||
                         res == MBEDTLS_MPS_MSG_ALERT );
            if( res == MBEDTLS_MPS_MSG_ALERT )
                break;
            retry++;
        }

        TEST_ASSERT( mps_l3_read_alert( &srv, &alert_in ) == 0 );

        TEST_ASSERT( alert_in.level ==
                     (uint8_t)( alert_level + alerts_remaining ) );
        TEST_ASSERT( alert_in.type ==
                     (uint8_t)( alert_type + alerts_remaining ) );

        /* Signal that message has been processed. */
        TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &cli ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_basic_ccs( int allocator_buffer_sz,
                               int layer0_buffer_sz,
                               int rec_sz,
                               int real_transforms,
                               int num_ccss,
                               int ccs_merging )
{
    int res;
    size_t ccs_remaining;

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli, srv;

    mps_l3_ccs_out ccs_out;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_CCS,
                                         1, ccs_merging != 0, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_CCS,
                                         1, ccs_merging != 0, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write handshake message to server
     */

    ccs_remaining = num_ccss;
    while( ccs_remaining-- )
    {
        ccs_out.epoch = 0;
        do
        {
            res = mps_l3_write_ccs( &cli, &ccs_out );
            TEST_ASSERT( res == 0 || res == MPS_ERR_WANT_WRITE );
        } while( res != 0 );

        /* Dispatch CCS message */
        TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
    }

    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

    /*
     * Server: Read handshake message from client
     */

    ccs_remaining = num_ccss;
    while( ccs_remaining-- )
    {
        do
        {
            res = mps_l3_read( &srv );
            TEST_ASSERT( res == MBEDTLS_MPS_MSG_CCS || res == MPS_ERR_WANT_WRITE );
        } while( res < 0 );

        /* Signal that message has been processed. */
        TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &cli ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3:MPS_L3_ALLOW_INTERLEAVED_SENDING */
void mbedtls_mps_l3_handshake_alert_interleaved( int allocator_buffer_sz,
                                                 int layer0_buffer_sz,
                                                 int rec_sz,
                                                 int real_transforms,
                                                 int num_msgs )
{
    /* This test is based on the test for gradual handshake sending
     * and receiving, but exercises the behavior of Layer 2 if a handshake
     * message spread across multiple records is interleaved by records
     * of other content type (in this case an alert message).
     *
     * On the sending side this needs the flag MPS_L3_ALLOW_INTERLEAVED_SENDING
     * to be set configuring Layer 3 to accept starting a message of different
     * content type while a handshake message is being paused. Also, the
     * handshake message, including its header, must be larger than the queue
     * that Layer 2 internally uses, as otherwise the writing will never be
     * paused. We're setting the queue size to 10 Bytes and the handshake size
     * to 8 Bytes, + 4 Bytes of handshake header, and send the handshake message
     * in two steps of 4 Bytes each, potentially interleaving them by an alert
     * record if we need to pause after the first step. We send several messages
     * to have this happen at least once.
     *
     * On the receiving side, we want to trigger the Layer 2 code path
     * where a content type different from handshake is received while
     * a reader for the handshake content type is paused. To this end,
     * we make sure that we're in the process of gathering handshake
     * data when the alert arrive, by requesting the 8 content bytes
     * in 3 + 5 Bytes, so that the alert arrives when we're waiting for
     * the 5-Byte chunk.
     *
     */

    int res;
    size_t msgs_remaining;

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli, srv;

    unsigned char *tmp;

    int send_state;
    int recv_state;

    int treat_alert_as_pausable = 0;

    size_t alerts_received = 0;
    size_t alerts_sent = 0;

    mps_l3_handshake_out hs_out;
    mps_l3_handshake_in hs_in;

    mps_l3_alert_out alert_out;
    mps_l3_alert_in alert_in;

    uint8_t const alert_type = 0xc;
    uint8_t const alert_level = 0x1a;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              10, 10, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              10, 10, mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         treat_alert_as_pausable == 1,
                                         1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         treat_alert_as_pausable == 1,
                                         1, 1 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &cli, dummy_c, &cli_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &cli, cli_epoch, MPS_EPOCH_WRITE ) == 0 );
    TEST_ASSERT( mps_l3_epoch_add( &srv, dummy_s, &srv_epoch ) == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &srv, srv_epoch, MPS_EPOCH_READ ) == 0 );

    /*
     * Client: Write handshake message to server
     */

    msgs_remaining = num_msgs;
    while( msgs_remaining-- )
    {
        /* TODO: It's planned to move the integral state variable into the
         *       extended writer object. */
        send_state = 0;
        while( 1 )
        {
            int pause = 0;

            /* This is uniform for initial writing and write continuations:
             * Just request a handshake write from Layer 3. If a handshake write
             * has been paused before, Layer 3 will attempt to continue it. */
            hs_out.epoch = 0;
            hs_out.type = 12;
            hs_out.len = 8;
            res = mps_l3_write_handshake( &cli, &hs_out );
            TEST_ASSERT( res == 0 || res == MPS_ERR_WANT_WRITE );
            if( res != 0 )
                continue;

            /*
             * Actual message writing code: In production-code,
             * this will be a separate function for each of the
             * handshake messages.
             *
             * The basic structure, however, will always be the same:
             * - Check the status and jump ahead to the respective place in
             *   the writing routine.
             * - Continue the writing from there, comitting the written data
             *   at each point of pre-emption. The more points of pre-emption
             *   and, hence, the smaller the chunk-sizes are, the less memory
             *   is needed by the writer internally.
             * - Pause and return if not enough data is available.
             */

            switch( send_state )
            {
                case 0:

                    /* Ask for outbuffer to write next chunk of data */
                    res = mbedtls_writer_get_ext( hs_out.wr_ext,
                                                  4,
                                                  &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_WRITER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Write contents */
                    for( size_t idx=0; idx<4; idx++ )
                        tmp[idx] = (unsigned char)( msgs_remaining + idx );

                    /* Commit and update state */
                    TEST_ASSERT( mbedtls_writer_commit_ext(
                                     hs_out.wr_ext ) == 0 );
                    send_state = 1;

                    /* Attempt to finish the writing -- should give an error
                     * because we have initially specified how much we intend
                     * to write. */
                    TEST_ASSERT( mps_l3_dispatch( &cli ) ==
                                 MPS_ERR_UNFINISHED_HS_MSG );

                    /* The missing `break;` is deliberate here, as
                     * we want to progress to the next reading stage. */

                case 1:

                    /* Ask for outbuffer to write next chunk of data */
                    res = mbedtls_writer_get_ext( hs_out.wr_ext, 4,
                                                  &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_WRITER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_WRITER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Write contents */
                    for( size_t idx=0; idx<4; idx++ )
                        tmp[idx] = (unsigned char)( 4 + msgs_remaining + idx );

                    /* Commit and update state */
                    TEST_ASSERT( mbedtls_writer_commit_ext(
                                     hs_out.wr_ext ) == 0 );
                    send_state = 2;

                default:
                    break;
            }

            if( pause == 1 )
            {
                TEST_ASSERT( mps_l3_pause_handshake( &cli ) == 0 );
                TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

                if( send_state == 1 )
                {
                    /* Send an alert */
                    alert_out.epoch = 0;
                    TEST_ASSERT( mps_l3_write_alert( &cli, &alert_out ) == 0 );
                    *alert_out.level = (uint8_t)( alert_level + msgs_remaining );
                    *alert_out.type = (uint8_t)( alert_type + msgs_remaining );
                    TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
                    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

                    alerts_sent++;
                }
            }
            else
            {
                break;
            }
        }

        TEST_ASSERT( mps_l3_dispatch( &cli ) == 0 );
    }

    TEST_ASSERT( mps_l3_flush( &cli ) == 0 );

    /* The test is pointless if the input parameters
     * were chosen in such a way that no handshake write
     * had to be paused. */
    TEST_ASSERT( alerts_sent != 0 );

    /*
     * Server: Read handshake message from client
     */

    /* This is an example of how gradual handshake
     * message reading can be implemented:
     * - A state variable (here `read_state`) keeps track of which
     *   parts of the message have already been read.
     * - In the beginning as well as when continuing a read,
     *   a read-request is filed to Layer 3, returning a handshake
     *   reader on success.
     * - The reader object is used to fetch the next chunk of incoming
     *   data, committing and updating the state afterwards.
     *   If not enough data is available in the reader, the reading
     *   is paused, and the reader's internal accumulator will ensure
     *   that the request can be served when the read continues.
     *
     * This works if either of the following conditions hold:
     * (a) Record are sent unfragmented and the Layer 1 read-buffer is
     *     large enough to hold them at once.
     * (b) The reader's accumulator is at least as large as the largest
     *     chunk of incoming data fetched and processed between two
     *     subsequent commits. If that's the case, then the Layer 1 read-buffer
     *     size can be arbitrary, as long as it's capable of holding the records
     *     sent by the peer.
     *
     * This way, speed and code-size can be traded for RAM usage by using
     * gradual message reading.
     */
    msgs_remaining = num_msgs;
    while( msgs_remaining-- )
    {
        recv_state = 0;
        while( 1 )
        {
            int pause = 0;

            res = mps_l3_read( &srv );

            TEST_ASSERT( res == MBEDTLS_MPS_MSG_HS ||
                         res == MBEDTLS_MPS_MSG_ALERT     ||
                         res == MPS_ERR_WANT_READ );
            if( res < 0 )
                continue;

            if( res == MBEDTLS_MPS_MSG_ALERT )
            {
                TEST_ASSERT( recv_state == 1 );
                TEST_ASSERT( mps_l3_read_alert( &srv, &alert_in ) == 0 );

                TEST_ASSERT( alert_in.level ==
                     (uint8_t)( alert_level + msgs_remaining ) );
                TEST_ASSERT( alert_in.type ==
                             (uint8_t)( alert_type + msgs_remaining ) );

                /* Signal that message has been processed. */
                TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );

                alerts_received++;
                continue;
            }

            TEST_ASSERT( mps_l3_read_handshake( &srv, &hs_in ) == 0 );
            TEST_ASSERT( hs_in.epoch == 0 );
            TEST_ASSERT( hs_in.type == 12 );
            TEST_ASSERT( hs_in.len == 8 );

            switch( recv_state )
            {
                case 0:

                    /* Fetch next chunk of incoming data */
                    res = mbedtls_reader_get_ext( hs_in.rd_ext, 3,
                                                  &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_READER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_READER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Process incoming data */
                    for( size_t idx=0; idx<3; idx++ )
                        TEST_ASSERT( tmp[idx] ==
                                     (uint8_t)( msgs_remaining + idx ) );

                    /* Commit last incoming chunk and update state */
                    TEST_ASSERT( mbedtls_reader_commit_ext(
                                     hs_in.rd_ext ) == 0 );
                    recv_state = 1;

                    /* Attempt to finish the reading -- should give an error because
                     * we know how large the message is in total.. */
                    TEST_ASSERT( mps_l3_read_consume( &srv ) ==
                                 MPS_ERR_UNFINISHED_HS_MSG );

                case 1:

                    /* Fetch next chunk of incoming data */
                    res = mbedtls_reader_get_ext( hs_in.rd_ext, 5,
                                                  &tmp, NULL );
                    TEST_ASSERT( res == 0 ||
                                 res == MBEDTLS_ERR_READER_OUT_OF_DATA );
                    if( res == MBEDTLS_ERR_READER_OUT_OF_DATA )
                    {
                        pause = 1;
                        break;
                    }

                    /* Process incoming data */
                    for( size_t idx=0; idx<5; idx++ )
                        TEST_ASSERT( tmp[idx] ==
                                     (uint8_t) ( 3 + msgs_remaining + idx ) );

                    /* Commit last incoming chunk and update state */
                    TEST_ASSERT( mbedtls_reader_commit_ext(
                                     hs_in.rd_ext ) == 0 );
                    recv_state = 2;

                default:
                    break;
            }

            if( pause == 1 )
                TEST_ASSERT( mps_l3_read_pause_handshake( &srv ) == 0 );
            else
                break;
        }

        TEST_ASSERT( mps_l3_read_consume( &srv ) == 0 );
    }

    printf( "Alerts received: %u, Total msgs: %u\n",
            (unsigned) alerts_received, (unsigned) num_msgs );
    TEST_ASSERT( alerts_received == alerts_sent );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mps_l3_free( &cli ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L3 */
void mbedtls_mps_l3_random( int allocator_buffer_sz,
                            int layer0_buffer_sz,
                            int num_epochs,
                            int num_chunks,
                            int max_chunk,
                            int real_transforms,
                            int write_probability,
                            int flush_probability )
{
    int ret;

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    uint8_t *buf;

    /* Layer 3 objects */
    mps_l3 endpoint[2];

    typed_data_chunk_l3 **chunks[2];
    size_t *chunks_per_epoch[2];
    mbedtls_mps_transform_t **epochs[2];
    mbedtls_mps_epoch_id read_epoch[2];
    size_t read_chunk[2];
    mbedtls_mps_epoch_id write_epoch[2];
    size_t write_chunk[2];

    mbedtls_mps_epoch_id latest_epoch[2];

    srand( 43 );

    epochs[0] = malloc( num_epochs * sizeof( mbedtls_mps_transform_t ) );
    epochs[1] = malloc( num_epochs * sizeof( mbedtls_mps_transform_t ) );
    chunks[0] = malloc( num_epochs * sizeof( typed_data_chunk* ) );
    chunks[1] = malloc( num_epochs * sizeof( typed_data_chunk* ) );
    chunks_per_epoch[0] = malloc( num_epochs * sizeof( size_t ) );
    chunks_per_epoch[1] = malloc( num_epochs * sizeof( size_t ) );

    TEST_ASSERT( chunks[0] != NULL && chunks_per_epoch[0] != NULL );
    TEST_ASSERT( chunks[1] != NULL && chunks_per_epoch[1] != NULL );
    TEST_ASSERT( epochs[0] != NULL && epochs[1] != NULL );

    for( size_t id=0; id < (unsigned) num_epochs; id++ )
    {
        size_t chunks_in_epoch;
        printf( "Initialize epoch %u\n", (unsigned) id );

        epochs[0][id] = malloc( sizeof( mbedtls_mps_transform_t ) );
        epochs[1][id] = malloc( sizeof( mbedtls_mps_transform_t ) );
        TEST_ASSERT( epochs[0][id] != NULL && epochs[1][id] != NULL );

#if !defined(TEST_SUITE_MPS_NO_SSL)
        if( real_transforms == 1 )
        {
            srand( id );
            epochs[0][id]->type = 1;
            epochs[1][id]->type = 1;
            build_transforms( &epochs[0][id]->real,
                              &epochs[1][id]->real,
                              MBEDTLS_CIPHER_AES_128_CBC,
                              MBEDTLS_MD_SHA1,
                              0, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                              mbedtls_test_rnd_std_rand, NULL );
        }
        else
#else
    ((void) real_transforms);
#endif
        {
            epochs[0][id]->type = 0;
            epochs[0][id]->mock.enabled = ( id > 0 );
            epochs[0][id]->mock.pad = id % 13 + 5;
            epochs[1][id]->type = 0;
            epochs[1][id]->mock.enabled = ( id > 0 );
            epochs[1][id]->mock.pad = id % 13 + 5;
        }

        for( size_t k=0; k<2; k++ )
        {
            printf( "Peer %u\n", (unsigned) k );

            /* Pick a random number of chunks per epoch */
            chunks_in_epoch = ( rand() % num_chunks ) + 1;
            chunks_per_epoch[k][id] = chunks_in_epoch;
            chunks[k][id] = malloc( sizeof( typed_data_chunk_l3 ) * chunks_in_epoch );
            TEST_ASSERT( chunks[k][id] != NULL );
            for( size_t chunk=0; chunk < chunks_in_epoch; chunk++ )
            {
                printf( "Chunk %u\n", (unsigned) chunk );
                switch( rand() % 4 )
                {
                    case 0: /* Handshake */
                    {
                        size_t cur_chunk_size;
                        printf( "Handshake message\n" );

                        chunks[k][id][chunk].type = MBEDTLS_MPS_MSG_HS;

                        cur_chunk_size = ( rand() % max_chunk ) + 1;
                        chunks[k][id][chunk].data.hs.buf = malloc( cur_chunk_size );
                        TEST_ASSERT( chunks[k][id][chunk].data.hs.buf != NULL );
                        chunks[k][id][chunk].data.hs.len = cur_chunk_size;
                        chunks[k][id][chunk].data.hs.type = rand() % 42;
                        chunks[k][id][chunk].data.hs.read_progress = 0;
                        chunks[k][id][chunk].data.hs.send_progress = 0;
                        mbedtls_test_rnd_std_rand( NULL, chunks[k][id][chunk].data.hs.buf,
                                      cur_chunk_size );

                    }
                    break;

                    case 1: /* Application */
                    {
                        size_t cur_chunk_size;
                        printf( "Application data message\n" );

                        chunks[k][id][chunk].type = MBEDTLS_MPS_MSG_APP;

                        cur_chunk_size = ( rand() % max_chunk ) + 1;
                        chunks[k][id][chunk].data.app.len = cur_chunk_size;
                        chunks[k][id][chunk].data.app.read_progress = 0;
                        chunks[k][id][chunk].data.app.send_progress = 0;
                        chunks[k][id][chunk].data.app.buf = malloc( cur_chunk_size );
                        TEST_ASSERT( chunks[k][id][chunk].data.app.buf != NULL );
                        mbedtls_test_rnd_std_rand( NULL, chunks[k][id][chunk].data.app.buf,
                                      cur_chunk_size );

                        for( size_t dump=0; dump < cur_chunk_size; dump++ )
                        {
                            printf( "%02x ", chunks[k][id][chunk].data.app.buf[dump] );
                            if( dump && dump % 16 == 15 )
                                printf( "\n" );
                        }
                        printf( "\n" );
                    }
                    break;

                    case 2: /* CCS */
                        printf( "CCS message\n" );
                        chunks[k][id][chunk].type = MBEDTLS_MPS_MSG_CCS;
                        break;


                    case 3: /* Alert */
                        printf( "Alert message\n" );
                        chunks[k][id][chunk].type = MBEDTLS_MPS_MSG_ALERT;
                        chunks[k][id][chunk].data.alert.type = (uint8_t) rand();
                        chunks[k][id][chunk].data.alert.level = (uint8_t) rand();
                        break;

                    default:
                        break;
                }
            }
        }
    }

    printf( "Initialize Layer 0\n" );

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_APP,
                                         0, 1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_APP,
                                         0, 1, 1 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_CCS,
                                         0, 0, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_CCS,
                                         0, 0, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &endpoint[0], &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &endpoint[1], &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    TEST_ASSERT( mps_l3_epoch_add( &endpoint[0], epochs[0][0],
                                   &latest_epoch[0] ) == 0 );
    TEST_ASSERT( latest_epoch[0] == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &endpoint[0], latest_epoch[0],
                                  MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );
    read_epoch[0] = write_epoch[0] = latest_epoch[0];

    TEST_ASSERT( mps_l3_epoch_add( &endpoint[1], epochs[1][0],
                                   &latest_epoch[1] ) == 0 );
    TEST_ASSERT( latest_epoch[1] == 0 );
    TEST_ASSERT( mps_l3_epoch_usage( &endpoint[1], latest_epoch[1],
                                  MPS_EPOCH_READ | MPS_EPOCH_WRITE ) == 0 );
    read_epoch[1] = write_epoch[1] = latest_epoch[1];

    write_chunk[0] = 0;
    write_chunk[1] = 0;
    read_chunk[0] = 0;
    read_chunk[1] = 0;

    while( read_epoch[0] < num_epochs ||
           read_epoch[1] < num_epochs )
    {
        size_t self;
        size_t peer;
        size_t read_or_write;

        self = rand() % 2;
        peer = self ^ 1;

        read_or_write = rand() % 100;
        if( read_or_write >= (unsigned) write_probability )
        {
            /* Reading */

            mbedtls_mps_epoch_id epoch;
            size_t chunk_num;
            typed_data_chunk_l3 *chunk;
            size_t data_remaining;
            size_t data_requested;
            size_t data_obtained;

            epoch = read_epoch[self];
            chunk_num = read_chunk[self];

            /* If we have already read everything, skip. */
            if( epoch == num_epochs )
            {
                printf( "SKIP READ, REACHED FINAL EPOCH %u\n",
                        (unsigned) epoch );
                continue;
            }

            printf( "[%u] READ, EPOCH %u, CHUNK %u / %u\n",
                    (unsigned) self, (unsigned) epoch,
                    (unsigned) ( chunk_num + 1 ),
                    (unsigned) chunks_per_epoch[peer][epoch] );

            /* Check if we need to switch the epoch */
            if( chunk_num == chunks_per_epoch[peer][epoch] )
            {
                /* Need to switch the epoch */
                chunk_num = 0;
                epoch++;

                if( epoch == num_epochs )
                {
                    read_epoch[self] = epoch;
                    read_chunk[self] = chunk_num;
                    printf( "SKIP READ, REACHED FINAL EPOCH %u\n",
                            (unsigned) epoch );
                    continue;
                }

                /* Check if have already added the epoch for writing. */
                if( epoch > write_epoch[self] )
                {
                    /* No, need to add epoch */
                    ret = mps_l3_epoch_add( &endpoint[self],
                                            epochs[self][epoch],
                                            &latest_epoch[self] );
                    TEST_ASSERT( ret == 0                             ||
                                 ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED );
                    if( ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED )
                        continue;

                    TEST_ASSERT( epoch == latest_epoch[self] );
                }

                TEST_ASSERT( mps_l3_epoch_usage( &endpoint[self],
                                                 epoch,
                                                 MPS_EPOCH_READ ) == 0 );

                printf( "[%u] SWITCHED TO READ EPOCH %u\n",
                        (unsigned) self, (unsigned) epoch );

                read_epoch[self] = epoch;
                read_chunk[self] = chunk_num;
            }

            chunk = &chunks[peer][epoch][chunk_num];

            printf( "Request read from L3\n" );
            ret = mps_l3_read( &endpoint[self] );
            if( ! ( ret == 0                        ||
                    ret == MPS_ERR_WANT_READ        ||
                    ret == MBEDTLS_MPS_MSG_APP ||
                    ret == MBEDTLS_MPS_MSG_HS   ||
                    ret == MBEDTLS_MPS_MSG_ALERT       ||
                    ret == MBEDTLS_MPS_MSG_CCS ) )
            {
                printf( "UNEXPECTED READ RESULT: %d\n",
                         ret );
            }
            TEST_ASSERT( ret == 0                        ||
                         ret == MPS_ERR_WANT_READ        ||
                         ret == MBEDTLS_MPS_MSG_APP ||
                         ret == MBEDTLS_MPS_MSG_HS   ||
                         ret == MBEDTLS_MPS_MSG_ALERT       ||
                         ret == MBEDTLS_MPS_MSG_CCS );

            if( ret == MPS_ERR_WANT_READ )
                continue;

            TEST_ASSERT( chunk->type == (mbedtls_mps_msg_type_t) ret );
            printf( "L3 read returned %u\n", (unsigned) ret );

            switch( ret )
            {
                case MBEDTLS_MPS_MSG_HS:
                {
                    mps_l3_handshake_in hs_in;

                    TEST_ASSERT( chunk->data.hs.read_progress <=
                                 chunk->data.hs.send_progress );
                    data_remaining = chunk->data.hs.len -
                        chunk->data.hs.read_progress;
                    data_requested = data_remaining;

                    ret = mps_l3_read_handshake( &endpoint[self], &hs_in );
                    TEST_ASSERT( ret == 0 );

                    ret = mbedtls_reader_get_ext( hs_in.rd_ext ,
                                                  data_requested, &buf,
                                                  &data_obtained );
                    TEST_ASSERT( ret == 0 );
                    TEST_ASSERT( memcmp( buf, chunk->data.hs.buf +
                                         chunk->data.hs.read_progress,
                                         data_obtained ) == 0 );
                    TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.rd_ext ) == 0 );

                    chunk->data.hs.read_progress += data_obtained;

                    if( data_obtained == data_requested )
                    {
                        TEST_ASSERT( mps_l3_read_consume( &endpoint[self] ) == 0 );
                        chunk_num++;
                        read_chunk[self] = chunk_num;
                    }
                    else
                    {
                        TEST_ASSERT( mps_l3_read_pause_handshake( &endpoint[self] ) == 0 );
                        printf( "[%u] Pause reading of HS message\n",
                                (unsigned) self );
                    }
                }
                break;

                case MBEDTLS_MPS_MSG_APP:
                {
                    mps_l3_app_in app_in;
                    printf( "Reading application data, state %u / %u / %u\n",
                            (unsigned) chunk->data.app.read_progress,
                            (unsigned) chunk->data.app.send_progress,
                            (unsigned) chunk->data.app.len );

                    TEST_ASSERT( chunk->data.app.read_progress <=
                                 chunk->data.app.send_progress );
                    printf( "Reading application data, state %u / %u\n",
                            (unsigned) chunk->data.app.read_progress,
                            (unsigned) chunk->data.app.send_progress );
                    data_remaining = chunk->data.app.send_progress -
                        chunk->data.app.read_progress;
                    if( data_remaining != 0 )
                        data_requested = ( rand() % data_remaining ) + 1;
                    else
                        data_requested = 0;

                    ret = mps_l3_read_app( &endpoint[self], &app_in );
                    TEST_ASSERT( ret == 0 );

                    printf( "Requested amount of data: %u\n",
                            (unsigned) data_requested );
                    ret = mbedtls_reader_get( app_in.rd ,
                                              data_requested, &buf,
                                              &data_obtained );
                    TEST_ASSERT( ret == 0 );
                    TEST_ASSERT( memcmp( buf, chunk->data.app.buf +
                                         chunk->data.app.read_progress,
                                         data_obtained ) == 0 );
                    TEST_ASSERT( mbedtls_reader_commit( app_in.rd ) == 0 );

                    chunk->data.app.read_progress += data_obtained;
                    TEST_ASSERT( mps_l3_read_consume( &endpoint[self] ) == 0 );

                    if( chunk->data.app.read_progress == chunk->data.app.len )
                    {
                        chunk_num++;
                        read_chunk[self] = chunk_num;
                    }
                }
                break;

                case MBEDTLS_MPS_MSG_ALERT:
                {
                    mps_l3_alert_in alert_in;
                    ret = mps_l3_read_alert( &endpoint[self], &alert_in );
                    TEST_ASSERT( ret == 0 );
                    TEST_ASSERT( alert_in.level == chunk->data.alert.level );
                    TEST_ASSERT( alert_in.type == chunk->data.alert.type );
                    TEST_ASSERT( mps_l3_read_consume( &endpoint[self] ) == 0 );

                    chunk_num++;
                    read_chunk[self] = chunk_num;
                }
                break;

                case MBEDTLS_MPS_MSG_CCS:
                    TEST_ASSERT( mps_l3_read_consume( &endpoint[self] ) == 0 );

                    chunk_num++;
                    read_chunk[self] = chunk_num;
                    break;

                default:
                    break;
            }
        }
        else
        {
            /* Writing */

            uint8_t flush_or_write;

            mbedtls_mps_epoch_id epoch;
            size_t chunk_num;
            typed_data_chunk_l3 *chunk;

            size_t data_remaining;
            size_t data_requested;
            size_t data_obtained;

            /* If we have already written everything, skip. */
            epoch = write_epoch[self];
            chunk_num = write_chunk[self];

            /* Choose between flushing and writing */
            flush_or_write = rand() % 100;
            if( flush_or_write < (unsigned) flush_probability )
            {
                /* Flushing */
                printf( "[%u] FLUSHING, EPOCH %u, CHUNK %u\n",
                        (unsigned) self, (unsigned) epoch,
                        (unsigned) chunk_num );
                ret = mps_l3_flush( &endpoint[self] );
                TEST_ASSERT( ret == MPS_ERR_WANT_WRITE || ret == 0 );
                if( ret == MPS_ERR_WANT_WRITE )
                    printf( "WANT_WRITE\n" );

                continue;
            }

            if( epoch == num_epochs )
            {
                printf( "SKIP WRITE, REACHED FINAL EPOCH %u\n",
                        (unsigned) epoch );
                continue;
            }

            printf( "[%u] WRITE, EPOCH %u, CHUNK %u / %u\n",
                    (unsigned) self, (unsigned) epoch,
                    (unsigned) ( chunk_num + 1 ),
                    (unsigned) chunks_per_epoch[self][epoch] );

            /* Check if we need to switch the epoch */
            if( chunk_num == chunks_per_epoch[self][epoch] )
            {
                /* Need to switch the epoch */
                chunk_num = 0;
                epoch++;

                if( epoch == num_epochs )
                {
                    write_epoch[self] = epoch;
                    write_chunk[self] = chunk_num;
                    printf( "SKIP WRITE, REACHED FINAL EPOCH %u\n",
                            (unsigned) epoch );
                    continue;
                }

                printf( "[%u] SWITCH TO WRITE EPOCH %u, READ EPOCH %u\n",
                        (unsigned) self, (unsigned) epoch,
                        (unsigned) read_epoch[ self] );

                /* Check if have already added the epoch for writing. */
                if( epoch > read_epoch[self] )
                {
                    /* No, need to add epoch */
                    ret = mps_l3_epoch_add( &endpoint[self],
                                            epochs[self][epoch],
                                            &latest_epoch[self] );
                    TEST_ASSERT( ret == 0                             ||
                                 ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED );
                    if( ret == MPS_ERR_EPOCH_WINDOW_EXCEEDED )
                        continue;

                    TEST_ASSERT( epoch == latest_epoch[self] );
                }

                TEST_ASSERT( mps_l3_epoch_usage( &endpoint[self],
                                                 epoch,
                                                 MPS_EPOCH_WRITE ) == 0 );

                printf( "[%u] SWITCHED TO WRITE EPOCH %u\n",
                        (unsigned) self, (unsigned) epoch );

                write_epoch[self] = epoch;
                write_chunk[self] = chunk_num;
            }

            chunk = &chunks[self][epoch][chunk_num];

            switch( chunk->type )
            {
                case MBEDTLS_MPS_MSG_HS:
                {
                    mps_l3_handshake_out hs_out;
                    hs_out.epoch = epoch;
                    hs_out.type = chunk->data.hs.type;
                    hs_out.len = chunk->data.hs.len;

                    ret = mps_l3_write_handshake( &endpoint[self], &hs_out );
                    TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                    if( ret != 0 )
                        continue;

                    data_remaining = chunk->data.hs.len - chunk->data.hs.send_progress;
                    data_requested = data_remaining;

                    ret = mbedtls_writer_get_ext( hs_out.wr_ext, data_requested,
                                                  &buf, &data_obtained );
                    TEST_ASSERT( ret == 0 );

                    memcpy( buf, chunk->data.hs.buf +
                            chunk->data.hs.send_progress,
                            data_obtained );
                    chunk->data.hs.send_progress += data_obtained;

                    ret = mbedtls_writer_commit_ext( hs_out.wr_ext );
                    TEST_ASSERT( ret == 0 );

                    if( chunk->data.hs.send_progress == chunk->data.hs.len )
                    {
                        TEST_ASSERT( mps_l3_dispatch( &endpoint[self] ) == 0 );
                        chunk_num++;
                        write_chunk[self] = chunk_num;
                    }
                    else
                    {
                        TEST_ASSERT( mps_l3_pause_handshake( &endpoint[self] ) == 0 );
                        printf( "[%u] Pause writing of HS message\n",
                                (unsigned) self );
                    }
                }
                break;

                case MBEDTLS_MPS_MSG_APP:
                {
                    mps_l3_app_out app_out;
                    app_out.epoch = epoch;

                    printf( "Write application data, state %u / %u\n",
                            (unsigned) chunk->data.app.send_progress,
                            (unsigned) chunk->data.app.len );

                    ret = mps_l3_write_app( &endpoint[self], &app_out );
                    TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                    if( ret != 0 )
                        continue;

                    data_remaining = chunk->data.app.len - chunk->data.app.send_progress;
                    data_requested = data_remaining;

                    ret = mbedtls_writer_get( app_out.wr, data_requested,
                                                  &buf, &data_obtained );
                    TEST_ASSERT( ret == 0 );

                    memcpy( buf, chunk->data.app.buf +
                            chunk->data.app.send_progress,
                            data_obtained );
                    chunk->data.app.send_progress += data_obtained;

                    printf( "Requested %u, got %u\n",
                            (unsigned) data_requested,
                            (unsigned) data_obtained );

                    ret = mbedtls_writer_commit( app_out.wr );
                    TEST_ASSERT( ret == 0 );

                    TEST_ASSERT( mps_l3_dispatch( &endpoint[self] ) == 0 );

                    if( chunk->data.app.send_progress == chunk->data.app.len )
                    {
                        chunk_num++;
                        write_chunk[self] = chunk_num;
                    }
                }
                break;

                case MBEDTLS_MPS_MSG_ALERT:
                {
                    mps_l3_alert_out alert_out;
                    alert_out.epoch = epoch;

                    ret = mps_l3_write_alert( &endpoint[self], &alert_out );
                    TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                    if( ret != 0 )
                        continue;

                    *alert_out.level = chunk->data.alert.level;
                    *alert_out.type = chunk->data.alert.type;

                    TEST_ASSERT( mps_l3_dispatch( &endpoint[self] ) == 0 );

                    chunk_num++;
                    write_chunk[self] = chunk_num;
                }
                break;

                    break;

                case MBEDTLS_MPS_MSG_CCS:
                {
                    mps_l3_ccs_out ccs_out;
                    ccs_out.epoch = epoch;

                    ret = mps_l3_write_ccs( &endpoint[self], &ccs_out );
                    TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                    if( ret != 0 )
                        continue;

                    TEST_ASSERT( mps_l3_dispatch( &endpoint[self] ) == 0 );

                    chunk_num++;
                    write_chunk[self] = chunk_num;
                }
                break;

                default:
                    break;
            }
        }
    }

exit:

    /*
     * Wrapup
     */

    mps_l3_free( &endpoint[0] );
    mps_l3_free( &endpoint[1] );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );

    printf( "Cleanup Chunks\n" );
    for( size_t id=0; id < (unsigned) num_epochs; id++ )
    {
        for( size_t k=0; k<2; k++ )
        {
            size_t chunks_in_epoch = chunks_per_epoch[k][id];
            for( size_t chunk=0; chunk < chunks_in_epoch; chunk++ )
            {
                typed_data_chunk_l3 *cur_chunk = &chunks[k][id][chunk];
                switch( cur_chunk->type )
                {
                    case MBEDTLS_MPS_MSG_HS:
                        free( cur_chunk->data.hs.buf );
                        break;

                    case MBEDTLS_MPS_MSG_APP:
                        free( cur_chunk->data.app.buf );
                        break;

                    default:
                        break;
                }
            }
            free( chunks[k][id] );
        }
    }

    free( chunks_per_epoch[ 0 ] );
    free( chunks_per_epoch[ 1 ] );
    free( chunks[0] );
    free( chunks[1] );
    free( epochs[0] );
    free( epochs[1] );

}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L4 */
void mbedtls_mps_l4_basic_handshake( int allocator_buffer_sz,
          int layer0_buffer_sz,
          int rec_sz,
          int real_transforms,
          int length_known,
          int multiple_fetch,
          int intermediate_commit,
          int partial_commit )
{
    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli_l3, srv_l3;

    /* Layer 4 objects */
    mbedtls_mps cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mbedtls_mps_handshake_out hs_out;
    mbedtls_mps_handshake_in hs_in;

    size_t additional_fetch = partial_commit ? 10 : 0;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli_l3, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv_l3, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    /* Initialize Layer 4 */
    TEST_ASSERT( mbedtls_mps_init( &cli, &cli_l3,
                                   MBEDTLS_MPS_MODE_STREAM ) == 0 );
    TEST_ASSERT( mbedtls_mps_init( &srv, &srv_l3,
                                   MBEDTLS_MPS_MODE_STREAM ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &cli, dummy_c,
                                               &cli_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_outgoing_keys( &cli, cli_epoch ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &srv, dummy_s,
                                               &srv_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_incoming_keys( &srv, srv_epoch ) == 0 );

    /*
     * Client: Write handshake message to server
     */

    hs_out.type = 12;

    if( length_known )
        hs_out.length = 20;
    else
        hs_out.length = MPS_L3_LENGTH_UNKNOWN;

    TEST_ASSERT( mbedtls_mps_write_handshake( &cli, &hs_out, NULL, NULL ) == 0 );

    if( multiple_fetch )
    {
        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle, 10,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx<10; idx++ )
            tmp[idx] = (unsigned char) idx;

        if( intermediate_commit )
            TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle )  == 0 );

        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle,
                                             10 + additional_fetch,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx< 10 + additional_fetch ; idx++ )
            tmp[idx] = (unsigned char) ( 10 + idx );
    }
    else
    {
        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle,
                                             20 + additional_fetch,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx<20 + additional_fetch; idx++ )
            tmp[idx] = (unsigned char) idx;
    }

    if( !partial_commit )
    {
        /* Commit and update state */
        TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle ) == 0 );
    }
    else
    {
        /* Commit and update state */
        TEST_ASSERT( mbedtls_writer_commit_partial_ext( hs_out.handle,
                                                    additional_fetch ) == 0 );
    }

    /* Check that writer is blocked. */
    if( !length_known && partial_commit )
    {
        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle, 10, &tmp, NULL ) ==
                     MBEDTLS_ERR_WRITER_UNEXPECTED_OPERATION );
    }

    /* Dispatch handshake message */
    TEST_ASSERT( mbedtls_mps_dispatch( &cli ) == 0 );
    TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 );

    /*
     * Server: Read handshake message from client
     */

    TEST_ASSERT( mbedtls_mps_read( &srv ) == MBEDTLS_MPS_MSG_HS );

    TEST_ASSERT( mbedtls_mps_read_handshake( &srv, &hs_in ) == 0 );
    TEST_ASSERT( hs_in.type   == 12 );
    TEST_ASSERT( hs_in.length == 20 );

    /* Fetch next chunk of incoming data */
    TEST_ASSERT( mbedtls_reader_get_ext( hs_in.handle, 20, &tmp, NULL ) == 0 );

    /* Process incoming data */
    for( size_t idx=0; idx<10; idx++ )
        TEST_ASSERT( tmp[idx] == (unsigned char) idx );

    /* Commit last incoming chunk and update state */
    TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.handle ) == 0 );

    /* Signal that message has been processed. */
    TEST_ASSERT( mbedtls_mps_read_consume( &srv ) == 0 );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mbedtls_mps_free( &cli ) == 0 );
    TEST_ASSERT( mbedtls_mps_free( &srv ) == 0 );
    TEST_ASSERT( mps_l3_free( &cli_l3 ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv_l3 ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L4 */
void mbedtls_mps_l4_disruption( int allocator_buffer_sz,
          int layer0_buffer_sz,
          int rec_sz,
          int real_transforms,
          int shutdown )
{
    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli_l3, srv_l3;

    /* Layer 4 objects */
    mbedtls_mps cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mbedtls_mps_handshake_out hs_out;
    mbedtls_mps_handshake_in hs_in;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

#if !defined(TEST_SUITE_MPS_NO_SSL)
    if( real_transforms == 1 )
    {
        dummy_c->type = 1;
        dummy_s->type = 1;
        build_transforms( &dummy_c->real,
                          &dummy_s->real,
                          MBEDTLS_CIPHER_AES_128_CBC,
                          MBEDTLS_MD_SHA1,
                          1, 0, MBEDTLS_SSL_MINOR_VERSION_3,
                          mbedtls_test_rnd_std_rand, NULL );
    }
    else
#else
    ((void) real_transforms);
#endif
    {
        dummy_s->type = 0;
        dummy_s->mock.enabled = 1;
        dummy_s->mock.pad = 5;
        dummy_c->type = 0;
        dummy_c->mock.enabled = 1;
        dummy_c->mock.pad = 5;
    }

    ((void) rec_sz);

    /* Initialize Layer 0 mock objects */
    layer0_bufsize = (size_t) layer0_buffer_sz;
    TEST_ASSERT( layer0_init( &s2c ) == 0 );
    TEST_ASSERT( layer0_init( &c2s ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L1_MODE_STREAM, &cli_alloc,
                              layer0_write_cli, layer0_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L1_MODE_STREAM, &srv_alloc,
                              layer0_write_srv, layer0_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_STREAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli_l3, &cli_l2, MPS_L3_MODE_STREAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv_l3, &srv_l2, MPS_L3_MODE_STREAM ) == 0 );

    /* Initialize Layer 4 */
    TEST_ASSERT( mbedtls_mps_init( &cli, &cli_l3,
                                   MBEDTLS_MPS_MODE_STREAM ) == 0 );
    TEST_ASSERT( mbedtls_mps_init( &srv, &srv_l3,
                                   MBEDTLS_MPS_MODE_STREAM ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &cli, dummy_c,
                                               &cli_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_outgoing_keys( &cli, cli_epoch ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &srv, dummy_s,
                                               &srv_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_incoming_keys( &srv, srv_epoch ) == 0 );

    /*
     * Client: Write handshake message to server
     */

    hs_out.type = 12;
    hs_out.length = 20;

    TEST_ASSERT( mbedtls_mps_write_handshake( &cli, &hs_out, NULL, NULL ) == 0 );

    TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle,
                                         20,
                                         &tmp, NULL ) == 0 );
    for( size_t idx=0; idx<20; idx++ )
        tmp[idx] = (unsigned char) idx;

    /* Commit and update state */
    TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle ) == 0 );

    /* Dispatch handshake message */
    TEST_ASSERT( mbedtls_mps_dispatch( &cli ) == 0 );

    if( shutdown )
    {
        /* Signal closure of write side */
        TEST_ASSERT( mbedtls_mps_close( &cli ) == 0 );

        /* We should still be allowed to attempt to receive something. */
        TEST_ASSERT( mbedtls_mps_read( &cli ) == MPS_ERR_WANT_READ );
    }
    else
    {
        /* Send a fatal alert. */
        TEST_ASSERT( mbedtls_mps_send_fatal( &cli, 12 ) == 0 );

        /* After sending a fatal alert, we must not even attempt to read. */
        TEST_ASSERT( mbedtls_mps_read( &cli ) == MBEDTLS_ERR_MPS_BLOCKED );
    }


    /* Attempt to write something should fail now. */
    TEST_ASSERT( mbedtls_mps_write_handshake( &cli, &hs_out, NULL, NULL ) ==
                 MBEDTLS_ERR_MPS_BLOCKED );

    /* But flushing should still work. */
    TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 );

    /*
     * Server: Read handshake message from client
     */

    TEST_ASSERT( mbedtls_mps_read( &srv ) == MBEDTLS_MPS_MSG_HS );

    TEST_ASSERT( mbedtls_mps_read_handshake( &srv, &hs_in ) == 0 );
    TEST_ASSERT( hs_in.type   == 12 );
    TEST_ASSERT( hs_in.length == 20 );

    /* Fetch next chunk of incoming data */
    TEST_ASSERT( mbedtls_reader_get_ext( hs_in.handle, 20, &tmp, NULL ) == 0 );

    /* Process incoming data */
    for( size_t idx=0; idx<10; idx++ )
        TEST_ASSERT( tmp[idx] == (unsigned char) idx );

    /* Commit last incoming chunk and update state */
    TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.handle ) == 0 );

    /* Signal that message has been processed. */
    TEST_ASSERT( mbedtls_mps_read_consume( &srv ) == 0 );

    if( shutdown )
    {
        /* Next, the closure notification should be received */
        TEST_ASSERT( mbedtls_mps_read( &srv) == MBEDTLS_ERR_MPS_CLOSE_NOTIFY );
    }
    else
    {
        /* The fatal alert should be received. */
        TEST_ASSERT( mbedtls_mps_read( &srv ) ==
                     MBEDTLS_ERR_MPS_FATAL_ALERT_RECEIVED );
    }

    /* Trying to read anything more from the peer should be blocked. */
    TEST_ASSERT( mbedtls_mps_read( &srv ) == MBEDTLS_ERR_MPS_BLOCKED );

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mbedtls_mps_free( &cli ) == 0 );
    TEST_ASSERT( mbedtls_mps_free( &srv ) == 0 );
    TEST_ASSERT( mps_l3_free( &cli_l3 ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv_l3 ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_free( &s2c );
    layer0_free( &c2s );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L4 */
void mbedtls_mps_l4_dtls_fragmentation( int allocator_buffer_sz,
                                        int retransmission_callback,
                                        int num_hs )
{
    int ret;

    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli_l3, srv_l3;

    /* Layer 4 objects */
    mbedtls_mps cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mbedtls_mps_handshake_out hs_out;
    mps_l3_handshake_in hs_in;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    size_t hs_len    = 100;
    size_t hs_offset;

    unsigned iteration;

    mbedtls_test_rnd_std_rand( NULL, (unsigned char*) &cli, sizeof( cli ) );
    mbedtls_test_rnd_std_rand( NULL, (unsigned char*) &srv, sizeof( srv ) );

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L2_MODE_DATAGRAM,
                              &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L2_MODE_DATAGRAM,
                              &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_DATAGRAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_DATAGRAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli_l3, &cli_l2, MPS_L3_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv_l3, &srv_l2, MPS_L3_MODE_DATAGRAM ) == 0 );

    /* Initialize Layer 4 */
    TEST_ASSERT( mbedtls_mps_init( &cli, &cli_l3,
                                   MBEDTLS_MPS_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mbedtls_mps_init( &srv, &srv_l3,
                                   MBEDTLS_MPS_MODE_DATAGRAM ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &cli, dummy_c,
                                               &cli_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_outgoing_keys( &cli, cli_epoch ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &srv, dummy_s,
                                               &srv_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_incoming_keys( &srv, srv_epoch ) == 0 );

    /*
     * Client: Write handshake message to server
     */

    for( iteration=0; iteration < (unsigned) num_hs; iteration++ )
    {
        hs_offset   = 0;
        hs_out.type = iteration;

        if( retransmission_callback == 0 )
        {
            /* TODO: Allow unknown length! */
            /* hs_out.length = MBEDTLS_MPS_LENGTH_UNKNOWN; */
            hs_out.length = hs_len + iteration;
            TEST_ASSERT( mbedtls_mps_write_handshake( &cli, &hs_out,
                                                      NULL, NULL ) == 0 );
        }
        else
        {
            hs_out.length = hs_len + iteration;
            TEST_ASSERT( mbedtls_mps_write_handshake( &cli, &hs_out,
                                                      mps_l4_dummy_callback,
                                                      NULL ) == 0 );
        }

        TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle, hs_len + iteration,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx<(unsigned) ( hs_len + iteration ); idx++ )
            tmp[idx] = (unsigned char) idx;

        /* Commit and update state */
        TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle ) == 0 );

        /* Dispatch handshake message */
        TEST_ASSERT( mbedtls_mps_dispatch( &cli ) == 0 );
        TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 );

        /*
         * Server: Read handshake message from client
         */

        while( 1 )
        {
            ret = mps_l3_read( &srv_l3 );
            if( ret == MPS_ERR_WANT_READ )
                break;

            TEST_ASSERT( ret == MBEDTLS_MPS_MSG_HS );

            TEST_ASSERT( mps_l3_read_handshake( &srv_l3, &hs_in ) == 0 );
            TEST_ASSERT( hs_in.type        == ( iteration )         );
            TEST_ASSERT( hs_in.frag_offset == hs_offset             );
            TEST_ASSERT( hs_in.len         == ( hs_len + iteration) );
            TEST_ASSERT( hs_in.seq_nr      == iteration             );

            TEST_ASSERT( mbedtls_reader_get_ext( hs_in.rd_ext ,
                                                 hs_in.frag_len,
                                                 &tmp, NULL ) == 0 );
            for( size_t idx=0; idx<(unsigned) hs_in.frag_len; idx++ )
                TEST_ASSERT( tmp[idx] == (unsigned char)( hs_offset + idx ) );

            /* Commit last incoming chunk and update state */
            TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.rd_ext ) == 0 );

            /* Signal that message fragment has been processed. */
            TEST_ASSERT( mps_l3_read_consume( &srv_l3 ) == 0 );

            hs_offset += hs_in.frag_len;
        }
        TEST_ASSERT( hs_offset == ( hs_len + iteration ) );
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mbedtls_mps_free( &cli ) == 0 );
    TEST_ASSERT( mbedtls_mps_free( &srv ) == 0 );
    TEST_ASSERT( mps_l3_free( &cli_l3 ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv_l3 ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */


/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L4 */
void mbedtls_mps_l4_dtls_reassembly( int allocator_buffer_sz,
                                     int retransmission_callback,
                                     int num_hs,
                                     int permute,
                                     int force_pause )
{
    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli_l3, srv_l3;

    /* Layer 4 objects */
    mbedtls_mps cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mbedtls_mps_handshake_out hs_out;
    mbedtls_mps_handshake_in  hs_in;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    size_t hs_len    = 100;

    unsigned iteration;
    dummy_cb_ctx dummy_ctx;
    dummy_ctx.bytes_per_chunk = 50;
    dummy_ctx.cur_chunk       = 0;
    dummy_ctx.num_chunks      = 2;

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L2_MODE_DATAGRAM,
                              &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L2_MODE_DATAGRAM,
                              &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_DATAGRAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_DATAGRAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli_l3, &cli_l2, MPS_L3_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv_l3, &srv_l2, MPS_L3_MODE_DATAGRAM ) == 0 );

    /* Initialize Layer 4 */
    TEST_ASSERT( mbedtls_mps_init( &cli, &cli_l3,
                                   MBEDTLS_MPS_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mbedtls_mps_init( &srv, &srv_l3,
                                   MBEDTLS_MPS_MODE_DATAGRAM ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &cli, dummy_c,
                                               &cli_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_outgoing_keys( &cli, cli_epoch ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &srv, dummy_s,
                                               &srv_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_incoming_keys( &srv, srv_epoch ) == 0 );

    /*
     * Client: Write handshake messages to server
     */

    iteration = 0;
    while( iteration < (size_t) num_hs )
    {
        int ret;
        hs_out.type = iteration;

        if( retransmission_callback == 0 )
        {
            hs_out.length = MBEDTLS_MPS_LENGTH_UNKNOWN;
            ret = mbedtls_mps_write_handshake( &cli, &hs_out,
                                               NULL, NULL );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
            if( ret == MPS_ERR_WANT_WRITE )
                continue;

            TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle,
                                                 hs_len, &tmp, NULL ) == 0 );

            for( size_t idx=0; idx<(unsigned) ( hs_len ); idx++ )
                tmp[idx] = (unsigned char) idx;

            TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle ) == 0 );

            /* Dispatch handshake message */
            TEST_ASSERT( mbedtls_mps_dispatch( &cli ) == 0 );
            iteration++;
        }
        else
        {
            hs_out.length = hs_len;
            ret = mbedtls_mps_write_handshake( &cli, &hs_out,
                                               mps_l4_dummy_callback,
                                               NULL );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
            if( ret == MPS_ERR_WANT_WRITE )
                continue;

            if( force_pause == 1 )
            {
                ret = mps_l4_dummy_callback( &dummy_ctx, hs_out.handle );
                TEST_ASSERT( ret == 0 ||
                             ret == MBEDTLS_MPS_RETRANSMISSION_CALLBACK_PAUSE );
                if( ret == 0 )
                {
                    TEST_ASSERT( mbedtls_mps_dispatch( &cli ) == 0 );
                    iteration++;
/*                    TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 ); */
                }
                else
                {
                    TEST_ASSERT( mbedtls_mps_write_pause( &cli ) == 0 );
/*                    TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 ); */
                }
            }
            else
            {
                TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle,
                                                     hs_len, &tmp, NULL ) == 0 );

                for( size_t idx=0; idx<(unsigned) ( hs_len ); idx++ )
                    tmp[idx] = (unsigned char) idx;

                TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle ) == 0 );

                /* Dispatch handshake message */
                TEST_ASSERT( mbedtls_mps_dispatch( &cli ) == 0 );
                iteration++;
/*                TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 ); */
            }
        }
    }

    TEST_ASSERT( mbedtls_mps_flush( &cli ) == 0 );

    /*
     * Apply a permutation to the underlying datagram transport.
     */

    if( permute )
    {
        layer0_dgram_permute( &c2s_d, 3 /* number of transpositions */ );
    }


    /*
     * Server: Read handshake messages from client
     */

    for( iteration=0; iteration < (size_t) num_hs; iteration++ )
    {
        while( 1 )
        {
            int ret;
            ret = mbedtls_mps_read( &srv );
            TEST_ASSERT( ret == MBEDTLS_MPS_MSG_HS ||
                         ret == MPS_ERR_WANT_READ  );
            if( ret == MBEDTLS_MPS_MSG_HS )
                break;
        }

        TEST_ASSERT( mbedtls_mps_read_handshake( &srv, &hs_in ) == 0 );

        TEST_ASSERT( hs_in.length == hs_len    );
        TEST_ASSERT( hs_in.type   == iteration );

        TEST_ASSERT( mbedtls_reader_get_ext( hs_in.handle, hs_in.length,
                                             &tmp, NULL ) == 0 );
        for( size_t idx=0; idx<(unsigned) ( hs_len ); idx++ )
            TEST_ASSERT( tmp[idx] == (unsigned char) idx );
        TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.handle ) == 0 );
        TEST_ASSERT( mbedtls_mps_read_consume( &srv ) == 0 );

    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mbedtls_mps_free( &cli ) == 0 );
    TEST_ASSERT( mbedtls_mps_free( &srv ) == 0 );
    TEST_ASSERT( mps_l3_free( &cli_l3 ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv_l3 ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );
}
/* END_CASE */

/* BEGIN_CASE depends_on:TEST_SUITE_MPS_L4 */
void mbedtls_mps_l4_dtls_flight_exchange( int allocator_buffer_sz,
                                          int retransmission_callback,
                                          int num_hs,
                                          int rounds,
                                          int server_reset,
                                          int permute,
                                          int use_mock_timer )
{
    /* Allocator objects */
    mps_alloc cli_alloc, srv_alloc;

    /* Layer 1 objects */
    mps_l1 cli_l1, srv_l1;

    /* Layer 2 objects */
    mps_l2 cli_l2, srv_l2;

    /* Layer 3 objects */
    mps_l3 cli_l3, srv_l3;

    /* Layer 4 objects */
    mbedtls_mps cli, srv;

    unsigned char *tmp;

    mbedtls_mps_epoch_id cli_epoch;
    mbedtls_mps_epoch_id srv_epoch;

    mbedtls_mps_handshake_out hs_out;
    mbedtls_mps_handshake_in  hs_in;

    /* Dummy record transformations for epoch 0 */
    mbedtls_mps_transform_t *dummy_c = malloc( sizeof( mbedtls_mps_transform_t ) );
    mbedtls_mps_transform_t *dummy_s = malloc( sizeof( mbedtls_mps_transform_t ) );

    size_t hs_len    = 100;
    unsigned iteration;
    unsigned round = 0;

    mock_timer_ctx timer_cli;
    mock_timer_ctx timer_srv;

    dummy_cb_ctx *cb_ctxs;
    cb_ctxs = malloc( sizeof( *cb_ctxs ) * ( rounds * num_hs ) );
    TEST_ASSERT( cb_ctxs != NULL );
    for( round = 0; round < (unsigned) ( rounds * num_hs ); round++ )
    {
        cb_ctxs[round].cur_chunk       = 0;
        cb_ctxs[round].num_chunks      = 2;
        cb_ctxs[round].bytes_per_chunk = 50;
    }

    dummy_s->type = 0;
    dummy_s->mock.enabled = 1;
    dummy_s->mock.pad = 5;
    dummy_c->type = 0;
    dummy_c->mock.enabled = 1;
    dummy_c->mock.pad = 5;

    /* Initialize Layer 0 mock objects */
    TEST_ASSERT( layer0_dgram_init( &s2c_d ) == 0 );
    TEST_ASSERT( layer0_dgram_init( &c2s_d ) == 0 );

    /* Initialize allocators */
    mps_alloc_init( &cli_alloc, allocator_buffer_sz );
    mps_alloc_init( &srv_alloc, allocator_buffer_sz );

    /* Initialize Layer 1 */
    TEST_ASSERT( mps_l1_init( &cli_l1, MPS_L2_MODE_DATAGRAM,
                              &cli_alloc,
                              layer0_dgram_write_cli,
                              layer0_dgram_read_cli ) == 0 );
    TEST_ASSERT( mps_l1_init( &srv_l1, MPS_L2_MODE_DATAGRAM,
                              &srv_alloc,
                              layer0_dgram_write_srv,
                              layer0_dgram_read_srv ) == 0 );

    /* Initialize and configure Layer 2 */
    TEST_ASSERT( mps_l2_init( &cli_l2, &cli_l1, MPS_L2_MODE_DATAGRAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_init( &srv_l2, &srv_l1, MPS_L2_MODE_DATAGRAM,
                              L2_DEFAULT_ACCUMULATOR_SIZE,
                              L2_DEFAULT_QUEUE_SIZE,
                              mbedtls_test_rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &cli_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_version( &srv_l2,
                        MBEDTLS_SSL_MINOR_VERSION_3 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &cli_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_HS,
                                         1, 1, 0 ) == 0 );
    TEST_ASSERT( mps_l2_config_add_type( &srv_l2, MBEDTLS_MPS_MSG_ALERT,
                                         1, 1, 0 ) == 0 );

    /* Initialize Layer 3 */
    TEST_ASSERT( mps_l3_init( &cli_l3, &cli_l2, MPS_L3_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mps_l3_init( &srv_l3, &srv_l2, MPS_L3_MODE_DATAGRAM ) == 0 );

    /* Initialize Layer 4 */
    TEST_ASSERT( mbedtls_mps_init( &cli, &cli_l3,
                                   MBEDTLS_MPS_MODE_DATAGRAM ) == 0 );
    TEST_ASSERT( mbedtls_mps_init( &srv, &srv_l3,
                                   MBEDTLS_MPS_MODE_DATAGRAM ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &cli, dummy_c,
                                               &cli_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_outgoing_keys( &cli, cli_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_incoming_keys( &cli, cli_epoch ) == 0 );

    TEST_ASSERT( mbedtls_mps_add_key_material( &srv, dummy_s,
                                               &srv_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_outgoing_keys( &srv, srv_epoch ) == 0 );
    TEST_ASSERT( mbedtls_mps_set_incoming_keys( &srv, srv_epoch ) == 0 );

    if( use_mock_timer )
    {
        srv.conf.p_timer = &timer_srv;
        srv.conf.f_set_timer = set_mock_timer;
        srv.conf.f_get_timer = get_mock_timer;
        cli.conf.p_timer = &timer_cli;
        cli.conf.f_set_timer = set_mock_timer;
        cli.conf.f_get_timer = get_mock_timer;
    }

    for( round=0; round < (unsigned) rounds; round++ )
    {
        mbedtls_mps *sender, *receiver;
        layer0_dgram_mock *l0;
        if( round % 2 == 0 )
        {
            sender   = &cli;
            receiver = &srv;
            l0       = &c2s_d;

            printf( "\n\n[[[[ ROUND %u, CLIENT ]]]]\n\n", (unsigned) round );
        }
        else
        {
            sender   = &srv;
            receiver = &cli;
            l0       = &s2c_d;

            printf( "\n\n[[[[ ROUND %u, SERVER ]]]]\n\n", (unsigned) round );
        }


        /* Send flight */

        for( iteration=0; iteration < (size_t) num_hs; iteration++ )
        {
            int ret;
            printf( "[[[ ITERATION %u / %u ]]]\n",
                    (unsigned) iteration, (unsigned) num_hs );
            hs_out.type = iteration;

            if( retransmission_callback == 0 )
            {
                hs_out.length = hs_len + iteration;

                while( 1 )
                {
                    ret = mbedtls_mps_write_handshake( sender, &hs_out,
                                                       NULL, NULL );
                    TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                    if( ret == 0 )
                        break;
                }
            }
            else
            {
                hs_out.length = hs_len;
                while( 1 )
                {
                    ret = mbedtls_mps_write_handshake( sender, &hs_out,
                                         mps_l4_dummy_callback,
                                         &cb_ctxs[round * num_hs + iteration] );
                    TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
                    if( ret == 0 )
                        break;
                }
            }

            /* Indicate the end of the flight */
            if( iteration == (size_t) ( num_hs - 1 ) )
            {
                /* After the initial exchange, reset the server. */
                if( ( round == 1 ) && ( server_reset == 1 ) )
                {
                    printf( "SERVER RESET\n" );
                    TEST_ASSERT( mbedtls_mps_write_set_flags( sender,
                                           MBEDTLS_MPS_FLIGHT_FINISHED ) == 0 );
                }
                else
                {
                    TEST_ASSERT( mbedtls_mps_write_set_flags( sender,
                                           MBEDTLS_MPS_FLIGHT_END ) == 0 );
                }
            }

            if( retransmission_callback == 0 )
            {
                TEST_ASSERT( mbedtls_writer_get_ext( hs_out.handle, hs_len + iteration,
                                                     &tmp, NULL ) == 0 );
                for( size_t idx=0; idx<(unsigned) ( hs_len + iteration ); idx++ )
                    tmp[idx] = (unsigned char) idx;

                /* Commit and update state */
                TEST_ASSERT( mbedtls_writer_commit_ext( hs_out.handle ) == 0 );

                /* Dispatch handshake message */
                TEST_ASSERT( mbedtls_mps_dispatch( sender ) == 0 );
            }
            else
            {
                ret = mps_l4_dummy_callback( &cb_ctxs[round * num_hs], hs_out.handle );
                TEST_ASSERT( ret == 0 ||
                             ret == MBEDTLS_MPS_RETRANSMISSION_CALLBACK_PAUSE );

                if( ret == 0 )
                    TEST_ASSERT( mbedtls_mps_dispatch( sender ) == 0 );
                else
                    TEST_ASSERT( mbedtls_mps_write_pause( sender ) );
            }
        }

        while( 1 )
        {
            int ret;
            ret = mbedtls_mps_flush( sender );
            TEST_ASSERT( ret == 0 || ret == MPS_ERR_WANT_WRITE );
            if( ret == 0 )
                break;
        }

        /* The sender has switched to RECEIVE mode now, hence
         * will check the retransmission timer to see if it
         * should retransmit. The mock timer always fires, so
         * we expect retransmission here. */
        while( 1 )
        {
            int ret;
            ret = mbedtls_mps_read( sender );
            if( ret != MPS_ERR_WANT_READ && ret != MPS_ERR_WANT_WRITE )
            {
                printf( "UNEXPECTED RET VALUE %d\n", ret );
            }
            TEST_ASSERT( ret == MPS_ERR_WANT_READ || ret == MPS_ERR_WANT_WRITE );

            if( ret == MPS_ERR_WANT_READ )
                break;
        }

        /*
         * Apply a permutation to the underlying datagram transport.
         */

        printf( "PERMUTE\n" );

        if( permute )
        {
            layer0_dgram_permute( l0, 5 /* number of transpositions */ );
        }

        printf( "RECEIVE\n" );

        /* Receive flight */
        for( iteration=0; iteration < (size_t) num_hs; iteration++ )
        {
            while( 1 )
            {
                int ret;
                ret = mbedtls_mps_read( receiver );
                TEST_ASSERT( ret == MBEDTLS_MPS_MSG_HS ||
                             ret == MPS_ERR_WANT_READ  ||
                             ret == MPS_ERR_WANT_WRITE );
                if( ret == MBEDTLS_MPS_MSG_HS )
                    break;
            }

            TEST_ASSERT( mbedtls_mps_read_handshake( receiver, &hs_in ) == 0 );

            TEST_ASSERT( hs_in.length == hs_len + iteration );
            TEST_ASSERT( hs_in.type   == iteration );

            TEST_ASSERT( mbedtls_reader_get_ext( hs_in.handle, hs_in.length,
                                                 &tmp, NULL ) == 0 );
            for( size_t idx=0; idx<(unsigned) ( hs_len + iteration ); idx++ )
                TEST_ASSERT( tmp[idx] == (unsigned char) idx );
            TEST_ASSERT( mbedtls_reader_commit_ext( hs_in.handle ) == 0 );

            if( iteration == (unsigned) ( num_hs - 1 ) )
            {
                TEST_ASSERT( mbedtls_mps_read_set_flags( receiver,
                                            MBEDTLS_MPS_FLIGHT_END ) == 0 );
            }

            TEST_ASSERT( mbedtls_mps_read_consume( receiver ) == 0 );
        }
    }

exit:

    /*
     * Wrapup
     */

    TEST_ASSERT( mbedtls_mps_free( &cli ) == 0 );
    TEST_ASSERT( mbedtls_mps_free( &srv ) == 0 );
    TEST_ASSERT( mps_l3_free( &cli_l3 ) == 0 );
    TEST_ASSERT( mps_l3_free( &srv_l3 ) == 0 );
    TEST_ASSERT( mps_l2_free( &cli_l2 ) == 0 );
    TEST_ASSERT( mps_l2_free( &srv_l2 ) == 0 );
    TEST_ASSERT( mps_l1_free( &cli_l1 ) == 0 );
    TEST_ASSERT( mps_l1_free( &srv_l1 ) == 0 );
    TEST_ASSERT( mps_alloc_free( &cli_alloc ) == 0 );
    TEST_ASSERT( mps_alloc_free( &srv_alloc ) == 0 );
    layer0_dgram_free( &s2c_d );
    layer0_dgram_free( &c2s_d );

    free( cb_ctxs );
}
/* END_CASE */
